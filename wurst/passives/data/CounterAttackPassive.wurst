package CounterAttackPassive

import LinkedList

import initlater BoardStack
import initlater Cell
import initlater StackPassive
import initlater PassiveType

import BoardTrigger
import BoardEntity
import SubStackActions
import KUtil

public class CounterAttackPassive extends StackPassive
    static PassiveType TYPE
    static function setup()
        TYPE = new PassiveType("Counter Attack", "Icons/PASCounterAttack.dds")
        TYPE.onCreate() entity -> 
            return new CounterAttackPassive(entity)
        TYPE.onCreateTooltipLines() amount -> 
            return createTooltipLines()

    private static constant int MAX_COUNTER = 1

    private static function createTooltipLines() returns LinkedList<string>
        return new LinkedList<string>
        ..add("This unit will counter an attack of opposing unit once per round")

    private int counter = MAX_COUNTER

    construct(BoardEntity entity)
        super(entity, TYPE)
        stack.getTriggers().addTurnEnd() (SequenzListener next) ->
            counter = MAX_COUNTER
            next.continue()

        stack.getTriggers().addOnAttacked() (BoardStack attacker, BoardStack defender, SequenzListener next) ->
            if attacker.isAlive() and defender.isAlive() and checkForCounterAttack(attacker, attacker.getCell())
                SubStackActions.attack(stack, attacker, false) (attackStatus) ->
                    counter --
                    next.continue()
            else
                next.continue()

    private function checkForCounterAttack(BoardStack _attacker, Cell fromCell) returns boolean
        if counter <= 0
            return false

        let distance = fromCell.getDistanceTo(stack.getCell())
        return distance.isBetween(stack.stats.getRange())