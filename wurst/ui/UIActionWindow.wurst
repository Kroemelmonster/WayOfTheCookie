package UIActionWindow

import Icons
import LinkedList

import PlayerData
import UIButton

import initlater OrderSystem
import initlater Action
import initlater BoardStack
import initlater UIController
import initlater BoardEntity
import initlater UISpellBook

constant framepointtype array[6] points = [FRAMEPOINT_TOPLEFT, FRAMEPOINT_TOP, FRAMEPOINT_TOPRIGHT, FRAMEPOINT_BOTTOMLEFT, FRAMEPOINT_BOTTOM, FRAMEPOINT_BOTTOMRIGHT]

class UIActionWindow
    private static framehandle self
    private static framehandle pane

    private static LinkedList<ActionButton> buttons
    private static framehandle array[10] actionPoints


    static function setup()
        self = createFrame("BACKDROP", "ActionWindow", GAME_UI, "", 0)
        ..setSize(0.1376, 0.1164)
        ..setPoint(FRAMEPOINT_BOTTOMRIGHT, GAME_UI, FRAMEPOINT_BOTTOMRIGHT)
        ..setTexture("UI/Textures/action-window-background.dds", 0, true)

        pane = createFrame("FRAME", "ActionWindowFrame", self, "", 0)
        ..setPoint(FRAMEPOINT_TOPLEFT, self, FRAMEPOINT_TOPLEFT, 0.006, -0.0274)
        ..setPoint(FRAMEPOINT_BOTTOMRIGHT, self, FRAMEPOINT_BOTTOMRIGHT, -0.0046, 0.007)

        buttons = new LinkedList<ActionButton>()
        for int i = 0 to points.length
            let btn = new ActionButton(self)
            btn.setPoint(points[i], pane, points[i], 0, 0)
            btn.onClick() () -> 
                activate(btn.action, GetTriggerPlayerData())
            btn.onMouseEnter() -> 
                onMouseEnter(btn.action, GetTriggerPlayerData())
            btn.onMouseLeave() -> 
                onMouseLeave(btn.action, GetTriggerPlayerData())
            buttons.add(btn)

        for int i = 0 to actionPoints.length
            actionPoints[i] = createFrame("BACKDROP", "wurst", self, "", 0)
                ..setSize(0.017, 0.013)
                ..setPoint(FRAMEPOINT_TOPLEFT, self, FRAMEPOINT_TOPLEFT, 0.01 + (0.01 * i), -0.008)

        hide()

        Player.forEachActive() (Player activePlayer) ->
            activePlayer.onAnyKeyPress() (Player p, string key) ->
                onkeyPress(p, key)

    private static function onkeyPress(Player p, string key)
        if OrderSystem.canOrder(p) == false
            return
        if key == "Escape"
            OrderSystem.resetCurrentSelectedAction(p.currentSelectedEntity)
            return

        let itr = p.currentSelectedEntity.getActions().iterator()
        boolean continue = true
        var counter = 0
        while itr.hasNext() and continue
            let action = itr.next()

            if action.showInActionBar() and action.canBeActivatedByKey(key)
                activate(action, p)
                // only trigger on action
                continue = false
            counter ++
        destroy itr
    
    static function self() returns framehandle
        return self

    private static function updateActionPointsLocal(BoardEntity entity, int previewLoosingPoints)
        let maxActionPoints = entity.getMaxActionPoints()
        let maxRemainingPoints = entity.getRemainingActionPoints()
        let startPreview = maxRemainingPoints - previewLoosingPoints
        for int i = 0 to actionPoints.length
            actionPoints[i].setVisible(i < maxActionPoints)
            if i < maxActionPoints
                if i < maxRemainingPoints
                    actionPoints[i].setAlpha(255)
                else
                    actionPoints[i].setAlpha(50)

                if i < startPreview or i >= maxRemainingPoints
                    actionPoints[i].setTexture("UI/Textures/action-point.dds", 0, true)
                else
                    actionPoints[i].setTexture("UI/Textures/action-point-preview.dds", 0, true)
                    actionPoints[i].setAlpha(120)

                
            
    static function updateActionPoints(BoardEntity entity, int previewLoosingPoints)
        // we just change it for the current active player
        // even if that player might have selected some other unit, the whole frame would not be visible so it does not matter
        // the other player who is currently not ordering also cant have this action frame --> does not matter
        if entity.getPlayer().playingBoard.isLocalPlayer()
            updateActionPointsLocal(entity, previewLoosingPoints)
    
    static function update(Player p)
        if p.isLocal() == false or p.isConntrolledByKI
            return

        if OrderSystem.couldOrderIFInteractable(p) == false
            hide()
            return
        let entity = p.currentSelectedEntity

        let currentAction = entity.getCurrentAction()
        let actionItr = entity.getActions().iterator()

        for ActionButton btn in buttons
            btn.setVisible(false)

        var index = 0
        while actionItr.hasNext()
            let action = actionItr.next()
            if action.showInActionBar()
                buttons.get(index).setAction(action, currentAction)
                index ++

        self.setVisible(true)
        updateActionPointsLocal(entity, 0)

        if entity.getType() == EntityType.HERO
            UISpellBook.update(p)
        
    private static function activate(Action action, Player p)
        if OrderSystem.canOrder(p) == false
            return

        if action.canActivate() == false
            return
        action.activate()

    private static function onMouseEnter(Action action, Player p)
        action.onUIMouseEnter()

    private static function onMouseLeave(Action action, Player p)
        if action != null
            action.onUIMouseLeave()

    static function hide(Player p)
        UISpellBook.hide(p)
        if p.isLocal()
            hide()

    static function hide()
        self.setVisible(false)