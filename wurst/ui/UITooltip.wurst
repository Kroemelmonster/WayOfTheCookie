package UITooltip

import PlayerData
import UIActionWindow
import LinkedList
import FramehandleNames
import KUtil
import initlater StatusType
import StatsModifier
import initlater Damage
import initlater StackType
import initlater Status
import ActionCost

constant LINE_HEIGHT = 0.0122
constant HEIGHT_OFFSET = 0.03
constant MIN_HEIGHT = 0.08

framehandle lineTest
real tooltipTextWidth

public class Description
    LinkedList<string> lines = new LinkedList<string>()

public enum TooltipAnchor
    TOP_LEFT
    TOP_RIGHT
    BOTTOM_RIGHT
    BOTTOM_LEFT
    BOTTOM_LEFT_UP

public class TooltipLine
    string str
    int resultingLines

    construct(string str)
        setLine(str)


    private construct(string str, int resultingLines)
        this.str = str
        this.resultingLines = resultingLines

    protected static function copy(TooltipLine line) returns TooltipLine
        return new TooltipLine(line.str, line.resultingLines)

    protected function setLine(string str)
        this.str = str
        if str.length() < 40
            resultingLines = 1
        else
            lineTest.setText(str)
            let width = lineTest.getWidth()
            resultingLines = (width / tooltipTextWidth).ceil()

public class Tooltip
    static constant COLOR_PRIMARY = colorA(255, 204, 0, 255).toColorString()
    static constant COLOR_NEGATIVE = color(200,50,50).toColorString()
    static constant COLOR_SECONDARY = color(145, 145, 145).toColorString()
    static constant COLOR_POSITIVE = color(75, 214, 19).toColorString()

    static constant DAMAGE_COLOR_PHYISICAL = colorA(200, 200, 200, 200).toColorString()
    static constant DAMAGE_COLOR_MAGICAL = colorA(43, 181, 245, 200).toColorString()
    static constant DAMAGE_COLOR_POISON = colorA(167, 252, 71, 199).toColorString()
    static constant DAMAGE_COLOR_FIRE = colorA(255, 120, 86, 200).toColorString()

    static Description DESCRIPTION_POISON = new Description()

    static function setup()
        DESCRIPTION_POISON.lines.add(Tooltip.secondaryString("Poisoned") + " is an Ailment that makes you suffer a small percentage of the initial hit as " + 
            Tooltip.coloredString(Tooltip.DAMAGE_COLOR_POISON, "poison") + " Damage")
        DESCRIPTION_POISON.lines.add("Additionaly to inflict its damage on the start of the turn, it also procs everytime the unit takes non-dot damage")
        

    protected string header = ""
    protected string key = ""
    protected LinkedList<TooltipLine> lines = new LinkedList<TooltipLine>
    protected string apCost = ""
    protected int cooldown = -1
    protected int mana = -1

    static function copy(Tooltip other) returns Tooltip
        let tooltip = new Tooltip()
        tooltip.header = other.header
        tooltip.key = other.key
        tooltip.apCost = other.apCost
        tooltip.cooldown = other.cooldown
        for TooltipLine line in other.lines
            tooltip.lines.add(TooltipLine.copy(line))

        return tooltip

    static function insert(LinkedList<string> list, Tooltip tt)
        for TooltipLine line in tt.lines
            list.add(line.str)

    static function create(string header) returns Tooltip
        let tooltip = new Tooltip()
        tooltip.header = header
        return tooltip

    static function playerColored(Player p, string str) returns string
        return p.c.toColorString() + str + "|r"

    static function coloredRange(string color, intRange r) returns string
        var str = color + r.min.toString()
        if r.min < r.max
            str +=  "|r - " + color + r.max.toString()
        str += "|r"
        return str

    @inline
    static function coloredInt(string color, int value) returns string
        return color + value.toString() + "|r"

    @inline
    static function coloredString(string color, string value) returns string
        return color + value + "|r"

    @inline
    static function primaryString(string value) returns string
        return COLOR_PRIMARY + value + "|r"

    @inline
    static function secondaryString(string value) returns string
        return COLOR_SECONDARY + value + "|r"

    @inline
    static function coloredSpecificDamageInstance(SpecificDamageInstance instance) returns string
        var str = coloredInt(damageType2Color(instance.damageInstance.damageType), instance.damage)
        if instance.amount > 0
            str +=  "   " + coloredInt(COLOR_NEGATIVE, instance.amount)
        return str

    @inline
    static function damageType2Color(DamageType dType) returns string
        switch dType
            case MAGIC
                return DAMAGE_COLOR_MAGICAL
            case POISON
                return DAMAGE_COLOR_POISON
            case FIRE
                return DAMAGE_COLOR_FIRE
            default
                return DAMAGE_COLOR_PHYISICAL

    @inline
    private static function statInner(string prefix, string data) returns string
        return prefix + " : " + data

    @inline
    static function stat(string prefix, string color, intRange value) returns string
        return statInner(prefix, coloredRange(color, value))

    @inline
    static function stat(string prefix, intRange value) returns string
        return statInner(prefix, coloredRange(Tooltip.COLOR_PRIMARY, value))

    @inline
    static function stat(string prefix, string color, string value) returns string
        return statInner(prefix, coloredString(color, value))

    @inline
    static function stat(string prefix, string color, int value) returns string
        return statInner(prefix, coloredInt(color, value))

    @inline
    static function stat(string prefix, int value) returns string
        return statInner(prefix, coloredInt(Tooltip.COLOR_PRIMARY, value))

    @inline
    static function stat(string prefix, DamagePreview value) returns string
        return statInner(prefix, coloredRange(damageType2Color(value.damageType), value.dmg.round()))

    @inline
    static function stat(string prefix, string value) returns string
        return statInner(prefix, coloredString(Tooltip.COLOR_PRIMARY, value))

    @inline
    static function coloredModiInt(int value) returns string
        if value > 0
            return coloredString(COLOR_POSITIVE, " +" + value.toString())
        else if value < 0
            return coloredString(COLOR_NEGATIVE, " " + value.toString())
        return ""

    @inline
    static function coloredModiReal(real value, int precision) returns string
        if value > 0.0
            return coloredString(COLOR_POSITIVE, " +" + value.toString(precision))
        else if value < 0.0
            return coloredString(COLOR_NEGATIVE, " " + value.toString(precision))
        return ""

    @inline
    static function percent(real perc) returns string
        return (perc * 100).toString(1) + "%"

    @inline
    static function coloredPercent(real perc) returns string
        if perc > 0
            return coloredString(COLOR_POSITIVE, "+" + percent(perc))
        else if perc < 0
            return coloredString(COLOR_NEGATIVE, percent(perc))
        return coloredString(COLOR_SECONDARY, percent(perc))

    @inline
    static function primaryPercent(real perc) returns string
        return coloredString(COLOR_PRIMARY, percent(perc))

    @inline
    static function modi(StatsModifier modi) returns string
        var str = coloredModiInt(modi.addBonus)
        if modi.multi != 100
            str += " (" + coloredPercent((modi.multi - 100) / 100.0) + ")"
        return str

    @inline
    function addLine(string str)
        lines.add(new TooltipLine(str))

    function setKey(string key)
        this.key = key

    @inline
    function addTooltip(Tooltip other, boolean once)
        for TooltipLine line in other.lines
            if line != null
                lines.add(line)
        if once
            destroy other

    function addStatusType(StatusType statusType, StatusData data)
        addLine(statInner("Status", coloredString(COLOR_SECONDARY, statusType.getName())))
        addTooltip(statusType.getTooltip(data), false)

    @inline
    function addSpecificDamagePreview(SpecificDamagePreview preview)
        addLine(Tooltip.playerColored(preview.target.getPlayer(), preview.target.getName()))
        addLine(Tooltip.stat("Damage", Tooltip.damageType2Color(preview.damagePreview.damageType), preview.damage))
        addLine(Tooltip.stat("Kills", Tooltip.COLOR_NEGATIVE, preview.amount))

    @inline
    function setLine(int index, string str)
        lines.get(index).setLine(str)

    @inline
    function getLine(int index) returns string
        return lines.get(index).str

    @inline
    function setCost(ActionCostPreset cost)
        this.apCost = cost.getAPAsText()
        if cost.hasCooldown()
            cooldown = cost.getMaxCooldown()
        else
            cooldown = -1
        if cost.hasMana()
            mana = cost.getMana()
        else
            mana = -1

    @inline
    function setManaCost(int value)
        mana = value

    protected function convert() returns string
        var str = ""
        for TooltipLine ttLine in lines
            if ttLine != null
                str += ttLine.str + "|n"
        return str

    protected function convertHeader() returns string
        var str = header
        if key != ""
            str += " [" +coloredString(COLOR_PRIMARY, key)+ "]"
        return str

    protected function getLineCount() returns int
        var count = 0
        for TooltipLine ttLine in lines
            if ttLine != null
                count += ttLine.resultingLines
        return count

    function display(Player p, boolean once, TooltipAnchor anchor, framehandle reference)
        UITooltip.setTooltip(p, this, anchor, reference)
        if once
            destroy this

    function display(Player p, boolean once)
        UITooltip.setTooltip(p, this)
        if once
            destroy this

    ondestroy
        destroy lines

class UITooltipIcon
    private framehandle iconFrame
    private framehandle textFrame

    construct(framehandle parent, int counter)
        textFrame = createFrame(FramehandleTypeNames.text, "", parent, "", 0)
            ..setSize(0.007, 0.013)
            ..setTextAlignment(TEXT_JUSTIFY_MIDDLE, TEXT_JUSTIFY_CENTER)
            ..setPoint(FRAMEPOINT_TOPRIGHT, parent, FRAMEPOINT_TOPRIGHT, 0.0, -0.0 - (counter * 0.013))
            ..setText("2")
            ..setVisible(false)

        iconFrame = createFrame(FramehandleTypeNames.backdrop, "", parent, "", 0)
            ..setSize(0.013, 0.013)
            ..setPoint(FRAMEPOINT_TOPRIGHT, parent, FRAMEPOINT_TOPRIGHT, -0.008, - (counter * 0.013))
            ..setTexture("UI/Textures/Icons/TooltipAddonManaIcon.dds", 0, true)
            ..setVisible(false)

    function update(string text, string icon)
        textFrame.setVisible(true)
        iconFrame.setVisible(true)
        textFrame.setText(text)
        iconFrame.setTexture(icon, 0, true)

    function hide()
        textFrame.setVisible(false)
        iconFrame.setVisible(false)



class UITooltip
    private static framehandle self
    private static framehandle text
    private static framehandle headerText

    private static UITooltipIcon array[3] icons

    static function setup()
        self = createFrame("BoxedText", GAME_UI, 0, 0)
        ..setWidth(0.25)
        ..setLevel(1000)
        ..setVisible(false)
        text = getFrame("BoxedTextValue")
        let header = getFrame("BoxedTextHeader")
        headerText = getFrame("BoxedTextHeaderValue")
        lineTest = getFrame("BoxedTextTestLines")
        ..setVisible(false)

        tooltipTextWidth = self.getWidth() - 0.01

        //self.setPoint(FRAMEPOINT_BOTTOMRIGHT, UIActionWindow.self(), FRAMEPOINT_TOPRIGHT)

        for int i = 0 to icons.length
            icons[i] = new UITooltipIcon(header, i)

    static protected function setTooltip(Player p, Tooltip tt, TooltipAnchor anchor, framehandle reference)
        if p.isLocal() == false
            return
        
        self.clearAllPoints()
        switch anchor
            case TOP_RIGHT
                self.setPoint(FRAMEPOINT_TOPRIGHT, reference, FRAMEPOINT_TOPLEFT)
            case BOTTOM_RIGHT
                self.setPoint(FRAMEPOINT_BOTTOMRIGHT, reference, FRAMEPOINT_BOTTOMLEFT)
            case BOTTOM_LEFT
                self.setPoint(FRAMEPOINT_BOTTOMLEFT, reference, FRAMEPOINT_BOTTOMRIGHT)
            case BOTTOM_LEFT_UP
                self.setPoint(FRAMEPOINT_BOTTOMLEFT, reference, FRAMEPOINT_TOPLEFT)
            default
                self.setPoint(FRAMEPOINT_TOPLEFT, reference, FRAMEPOINT_TOPRIGHT)
        setTooltipInner(tt)


    static protected function setTooltip(Player p, Tooltip tt)
        if p.isLocal() == false
            return
        
        self.clearAllPoints()
        self.setPoint(FRAMEPOINT_BOTTOMRIGHT, UIActionWindow.self(), FRAMEPOINT_TOPRIGHT)
        setTooltipInner(tt)

    private static function setTooltipInner(Tooltip tt)
        headerText.setText(tt.convertHeader())
        text.setText(tt.convert())
        let lineNumbers = tt.getLineCount()
        let height = lineNumbers * LINE_HEIGHT
        if height > MIN_HEIGHT
            self.setHeight(height + HEIGHT_OFFSET)
        else
            self.setHeight(MIN_HEIGHT + HEIGHT_OFFSET)
        self.setVisible(true)

        for int i = 0 to icons.length
            icons[i].hide()

        var curIcon = 0
        if tt.apCost != ""
            icons[curIcon].update(tt.apCost, "UI/Textures/Icons/TooltipAddonAPIcon.dds")
            curIcon++
        if tt.mana > 0
            icons[curIcon].update(tt.mana.toString(), "UI/Textures/Icons/TooltipAddonManaIcon.dds")
            curIcon++
        if tt.cooldown > 0
            icons[curIcon].update(tt.cooldown.toString(), "UI/Textures/Icons/TooltipAddonCooldownIcon.dds")
            //curIcon++

    static function hide(Player p)
        if p.isLocal()
            hide()

    static function hide()
        self.setVisible(false)