package UISpellBook
import UIInitiativeWindow
import UITooltip
import ClosureFrames
import PlayerData
import MouseContext

import Icons
import UIButton
import OrderSystem
import Action
import Spell

public class UISpellBookInfo
    protected boolean visible = false

class UISpell
    framehandle self
    protected ActionButton btn
    protected framehandle text
    protected framehandle costText
    
    construct(framehandle parent)
        self = createFrame("Spell", parent, 0, 0)
        text = getFrame("SpellText")
        costText = getFrame("SpellCostText")

        btn = new ActionButton(self)
        btn.setPoint(FRAMEPOINT_TOPLEFT, self, FRAMEPOINT_TOPLEFT, 0, 0)

    function setPoint(framepointtype point, framehandle relative, framepointtype relativePoint, real x, real y)
        self.setPoint(point, relative, relativePoint, x, y)

    function setVisible(boolean flag)
        self.setVisible(flag)

    function getAction() returns Action
        return btn.action

    function setSpell(Spell spell, Action currentAction)
        self.setVisible(true)
        text.setText(spell.getName())
        costText.setText(spell.getManaCost().toString())
        btn.setAction(spell, currentAction)
    
    function onClick(FrameHandleListener listener)
        btn.onClick(listener)

    function onMouseEnter(FrameHandleListener listener)
        btn.onMouseEnter(listener)

    function onMouseLeave(FrameHandleListener listener)
        btn.onMouseLeave(listener)

public class UISpellBook
    private static constant int MAX_SPELLS = 10
    private static framehandle self
    private static framehandle pane

    private static UISpell array[MAX_SPELLS] spells

    static function setup()
        self = createFrame("BasicBorderWindow", GAME_UI, 0, 0)
        ..setPoint(FRAMEPOINT_TOPLEFT, GAME_UI, FRAMEPOINT_TOPLEFT)
        ..setSize(0.3, 0.3)
        ..setVisible(false)
        
        pane = getFrame("WindowPane")

        let half = (MAX_SPELLS / 2).round()
        for int i = 0 to half - 1
            let index = (i * 2)
            spells[index] = new UISpell(pane)
            spells[index].onClick() () -> 
                activate(spells[index].getAction(), GetTriggerPlayerData())
            spells[index].onMouseEnter() -> 
                onMouseEnter(spells[index].getAction(), GetTriggerPlayerData())
            spells[index].onMouseLeave() -> 
                onMouseLeave(spells[index].getAction(), GetTriggerPlayerData())
            if i == 0
                spells[index].setPoint(FRAMEPOINT_TOPLEFT, pane, FRAMEPOINT_TOPLEFT, 0, 0)
                spells[index].setPoint(FRAMEPOINT_TOPRIGHT, pane, FRAMEPOINT_TOP, 0, 0)
            else
                spells[index].setPoint(FRAMEPOINT_TOPLEFT, spells[index - 2].self, FRAMEPOINT_BOTTOMLEFT, 0, -0.005)
                spells[index].setPoint(FRAMEPOINT_TOPRIGHT, spells[index - 2].self, FRAMEPOINT_BOTTOMRIGHT, 0, -0.005)
                

        for int i = 0 to half - 1
            let index = (i * 2) + 1
            spells[index] = new UISpell(pane)
            spells[index].onClick() () -> 
                activate(spells[index].getAction(), GetTriggerPlayerData())
            spells[index].onMouseEnter() -> 
                onMouseEnter(spells[index].getAction(), GetTriggerPlayerData())
            spells[index].onMouseLeave() -> 
                onMouseLeave(spells[index].getAction(), GetTriggerPlayerData())
            if i == 0
                spells[index].setPoint(FRAMEPOINT_TOPLEFT, pane, FRAMEPOINT_TOP, 0, 0)
                spells[index].setPoint(FRAMEPOINT_TOPRIGHT, pane, FRAMEPOINT_TOPRIGHT, 0, 0)
            else
                spells[index].setPoint(FRAMEPOINT_TOPLEFT, spells[index - 2].self, FRAMEPOINT_BOTTOMLEFT, 0, -0.005)
                spells[index].setPoint(FRAMEPOINT_TOPRIGHT, spells[index - 2].self, FRAMEPOINT_BOTTOMRIGHT, 0, -0.005)

    static function update(Player p)
        if p.isLocal() == false or p.isConntrolledByKI or p.spellBookInfo.visible == false
            return

        if OrderSystem.couldOrderIFInteractable(p) == false
            hide()
            return

        let entity = p.currentSelectedEntity

        let currentAction = entity.getCurrentAction()
        let actionItr = entity.getActions().iterator()

        for int i = 0 to MAX_SPELLS - 1
            spells[i].setVisible(false)

        var index = 0
        while actionItr.hasNext()
            let action = actionItr.next()
            if action.isSpell()
                let spell = action castTo Spell
                spells[index].setSpell(spell, currentAction)
                index ++
        
    private static function activate(Action action, Player p)
        if OrderSystem.canOrder(p) == false
            return
        if action.canActivate() == false
            return
        hide(p)
        action.activate()

    private static function onMouseEnter(Action action, Player p)
        action.onUIMouseEnter()

    private static function onMouseLeave(Action action, Player p)
        if action != null
            action.onUIMouseLeave()

    private static function hide()
        self.setVisible(false)

    static function hide(Player p)
        let info = p.spellBookInfo
        info.visible = false
        self.setVisible(info.visible)

    static function toggle(Player p)
        if p.isLocal() == false
            return
        let info = p.spellBookInfo
        info.visible = info.visible == false
        self.setVisible(info.visible)

        if info.visible == false
            return

        update(p)


