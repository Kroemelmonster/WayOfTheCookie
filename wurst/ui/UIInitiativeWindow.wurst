package UIInitiativeWindow

import LinkedList

import PlayerData
import UIButton

import initlater InitiativeList
import initlater BoardStack
import initlater MouseContext
import initlater BoardEntity
import UIButtonIcon
import UIHandle

constant MAX_ENTRYS = 14

class InitiativeCommandButton extends UIButtonIcon
    protected framehandle timeHandle
    protected framehandle textHandle

    construct(framehandle pane, boolean withTime)
        super(pane, false, true, false)
        setSize(0.035, 0.035)

        textHandle = createUIFrame("TEXT", self)
        ..setPoint(FRAMEPOINT_TOPLEFT, self, FRAMEPOINT_BOTTOMLEFT)
        ..setPoint(FRAMEPOINT_BOTTOMRIGHT, self, FRAMEPOINT_BOTTOMRIGHT, -0.002, 0.009)

        if withTime
            timeHandle = createUIFrame("TEXT", self)
            ..setPoint(FRAMEPOINT_BOTTOMLEFT, self, FRAMEPOINT_TOPLEFT)
            ..setPoint(FRAMEPOINT_BOTTOMRIGHT, self, FRAMEPOINT_TOPRIGHT)
            ..setHeight(0.009)
            ..setTextAlignment(TEXT_JUSTIFY_MIDDLE, TEXT_JUSTIFY_CENTER)

    protected function setText(string text)
        textHandle.setText(text)


class UIInitiativeWindow
    static framehandle self
    private static framehandle pane
    private static InitiativeCommandButton currentBtn
    private static InitiativeCommandButton array[MAX_ENTRYS] btns

    static function setup()
        self = createFrame("FRAME", "ActionWindowFrame", GAME_UI, "", 0)
        ..setVisible(false)
        ..setPoint(FRAMEPOINT_BOTTOMLEFT,  GAME_UI, FRAMEPOINT_BOTTOMLEFT)
        ..setSize(0.4, 0.07)
        pane = self

        currentBtn = new InitiativeCommandButton(pane, false)
        ..setPoint(FRAMEPOINT_TOPLEFT, pane, FRAMEPOINT_TOPLEFT, 0, 0)
        ..setScale(1.5)

        for int i = 0 to MAX_ENTRYS
            btns[i] = new InitiativeCommandButton(pane, true)
            if i == 0
                btns[i].setPoint(FRAMEPOINT_TOPLEFT, currentBtn.self, FRAMEPOINT_TOPRIGHT, 0.002, -0.0175)
            else
                btns[i].setPoint(FRAMEPOINT_TOPLEFT, btns[i - 1].self, FRAMEPOINT_TOPRIGHT, 0.002, 0)
            btns[i].onClick() () ->
                onClick(GetTriggerPlayerData(), i)
            btns[i].onMouseEnter() () ->
                onMouseEnter(GetTriggerPlayerData(), i)
            btns[i].onMouseLeave() () ->
                onMouseLeave(GetTriggerPlayerData())

    private static function getEntryAt(Player p, integer i) returns InitiativeEntry
        return p.playingBoard.getInitiative().get(i)

    private static function onClick(Player p, integer i)
        let entry = getEntryAt(p, i)
        if entry == null
            return
        
        let entityCell = entry.getEnitity().getBoardEntity().getCell()
        if entityCell != null
            MouseContext.forcePlayerSelect(p, entityCell)
    
    private static function onMouseEnter(Player p, integer i)
        let entry = getEntryAt(p, i)
        if entry == null
            return

        let entityCell = entry.getEnitity().getBoardEntity().getCell()
        if entityCell != null
            MouseContext.forceMouseEnter(p, entityCell)

    private static function onMouseLeave(Player p)
        MouseContext.forceMouseLeave(p)
        
    static function refresh(InitiativeList initiative)
        if initiative.getBoard().isLocalPlayer() == false
            return
        
        let cur = initiative.getCurrent()
        if cur != null
            refreshButton(currentBtn, cur.getBoardEntity())

        let iterator = initiative.iterator()
        for int i = 0 to MAX_ENTRYS
            let hasEntry = iterator.hasNext()
            btns[i].setVisible(hasEntry)

            if hasEntry
                let entry = iterator.next()
                refreshButton(btns[i], entry)

        destroy iterator

    private static function refreshButton(InitiativeCommandButton btn, InitiativeEntry entry)
        btn.timeHandle.setText(entry.getTime().toString())

        refreshButton(btn, entry.getEnitity().getBoardEntity())

    private static function refreshButton(InitiativeCommandButton btn, BoardEntity entity)
        btn.setIcon(entity.getIcon())
        let player1 = entity.getBoard().getPlayer(0)
        if player1.isLocal()
            btn.setBorderBasedOnPlayerRelationship(player1.getRelationshipStatusTo(entity.getPlayer()))
        let player2 = entity.getBoard().getPlayer(1)
        if player2.isLocal()
            btn.setBorderBasedOnPlayerRelationship(player2.getRelationshipStatusTo(entity.getPlayer()))

        switch(entity.getType())
            case STACK
                btn.setText(entity.toStack().stats.getAmount().toString())
            case HERO
                btn.setText("Hero")
        

    static function highlightEntity(Player p, BoardEntity highlightEntit)
        if p.isLocal() == false
            return

        let iterator = p.playingBoard.getInitiative().iterator()
        for int i = 0 to MAX_ENTRYS
            if iterator.hasNext()
                let stack = iterator.next().getEnitity().getBoardEntity()
                btns[i].showHighlight(highlightEntit == stack)

        destroy iterator

    static function setVisible(Player p, boolean flag)
        if p.isLocal()
            self.setVisible(flag)

    static function resetHighlight(Player p)
        if p.isLocal() == false
            return

        for int i = 0 to MAX_ENTRYS
            btns[i].showHighlight(false)
