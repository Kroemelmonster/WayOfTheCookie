package UIBoardActionMenu

import Icons
import LinkedList

import PlayerData
import UIButton

import initlater OrderSystem
import initlater Action
import initlater BoardEntity
import initlater UIWindowSpellBook
import ActionCost
import UIWindow
import UIHandle
import UIButtonIcon

class UIBoardActionButton extends UIButtonIcon
    private Action action

    construct(UIHandle parent)
        super(parent.self, true, false, true)
        setSize(0.035, 0.035)

        onClick() () -> 
            UIBoardActionMenu.activate(action, GetTriggerPlayerData())
        onMouseEnter() -> 
            action.onUIMouseEnter()
        onMouseLeave() -> 
            if action != null
                action.onUIMouseLeave()

    function setAction(Action action, Action currentAction, string key)
        this.action = action
        setVisible(true)
        setIcon(action.getIcon())
        action.setKey(key)

        let cost = action.getCost()
        setCounter(cost.getCurrentCharges())

        if action == currentAction
            enable()
            setGlowVisible(true)
        else
            setGlowVisible(false)
            if action.canActivate()
                enable()
            else
                if not cost.hasEnoughMana()
                    disable("UI/Textures/Button/BTNExtensionOverlayDisabledMana.dds")
                else if cost.isOnCooldown()
                    let cooldown = cost.getCurrentCooldown()
                    if cooldown > 0
                        disable("UI/Textures/Button/BTNExtensionOverlapCooldown"+cooldown.toString()+".dds")
                    else // a cooldown of 0 means the entity just used it and is not allowed to us it this turn again
                        disable("UI/Textures/Button/BTNExtensionOverlayDisabled.dds")
                else
                    disable("UI/Textures/Button/BTNExtensionOverlayDisabled.dds")

    function setEmpty()
        action = null
        setVisible(true)
        disable()
        setGlowVisible(false)
        setIcon("Icons/BTNDotted.dds")

class UIBoardActionMenu
    private static UIMenu menu

    private static UIBoardActionButton array[4] primaryBtns
    private static UIBoardActionButton array[4] secondaryBtns
    private static framehandle array[10] actionPoints

    private static constant string array[4] PRIMARY_KEYS = ["Q", "W", "E", "R"]
    private static constant string array[4] SECONDARY_KEYS = ["F", "D", "S", "A"] //its reverse !

    static function create()
        menu = UIMenu.create()
        ..setSize(0.17, 0.1164)
        ..setPointToGameUI(FRAMEPOINT_BOTTOMRIGHT, FRAMEPOINT_BOTTOMRIGHT)
        
        createUIFrame("BACKDROP", menu)
        ..setAllPoints(menu)
        ..setTexture("UI/BoardConsole/ActionWindowBackground.dds")

        primaryBtns[0] = new UIBoardActionButton(menu)
        ..setPoint(FRAMEPOINT_TOPLEFT, menu, FRAMEPOINT_TOPLEFT, 0.006, -0.0274)

        secondaryBtns[0] = new UIBoardActionButton(menu)
        ..setPoint(FRAMEPOINT_BOTTOMRIGHT, menu, FRAMEPOINT_BOTTOMRIGHT, -0.0046, 0.007)

        for int i = 1 to primaryBtns.length - 1
            primaryBtns[i] = new UIBoardActionButton(menu)
            ..setPoint(FRAMEPOINT_TOPLEFT, primaryBtns[i - 1], FRAMEPOINT_TOPRIGHT, 0.001, 0)

        for int i = 1 to secondaryBtns.length - 1
            secondaryBtns[i] = new UIBoardActionButton(menu)
            ..setPoint(FRAMEPOINT_TOPRIGHT, secondaryBtns[i - 1], FRAMEPOINT_TOPLEFT, -0.001, 0)

        for int i = 0 to actionPoints.length - 1
            actionPoints[i] = createUIFrame("BACKDROP", menu)
            ..setSize(0.025, 0.013)
            ..setPoint(FRAMEPOINT_TOPLEFT, menu, FRAMEPOINT_TOPLEFT, 0.007 + (0.016 * i), -0.008)

        hide()

        Player.forEachActive() (Player activePlayer) ->
            activePlayer.onAnyKeyPress() (Player p, string key) ->
                onkeyPress(p, key)

    protected static function activate(Action action, Player p)
        if not OrderSystem.canOrder(p)
            return
        if not action.canActivate()
            return
        action.activate()

    private static function onkeyPress(Player p, string key)
        if OrderSystem.canOrder(p) == false
            return
        if key == "Escape"
            OrderSystem.resetCurrentSelectedAction(p.currentSelectedEntity)
            return

        let itr = p.currentSelectedEntity.getActions().iterator()
        boolean continue = true
        var counter = 0
        while itr.hasNext() and continue
            let action = itr.next()

            if action.hasOption(ActionOption.DEFAULT) == false and action.canBeActivatedByKey(key)
                activate(action, p)
                // only trigger one action
                continue = false
            counter ++
        destroy itr
    
    static function self() returns framehandle
        return menu.self

    private static function updateActionPointsLocal(BoardEntity entity, int previewLoosingPoints)
        let maxActionPoints = entity.getMaxActionPoints()
        let maxRemainingPoints = entity.getRemainingActionPoints()
        let startPreview = maxRemainingPoints - previewLoosingPoints
        for int i = 0 to actionPoints.length - 1
            actionPoints[i].setVisible(i < maxActionPoints)
            if i < maxActionPoints
                if i >= maxRemainingPoints
                    actionPoints[i].setTexture("UI/Textures/Icons/ActionPointUsedIcon.dds")
                else if i >= startPreview
                    actionPoints[i].setTexture("UI/Textures/Icons/ActionPointUsingIcon.dds")
                else
                    actionPoints[i].setTexture("UI/Textures/Icons/ActionPointActiveIcon.dds")

    static function updateActionPoints(BoardEntity entity)
        if entity.getBoard().isLocalPlayer()
            updateActionPointsLocal(entity, 0)

    static function updateActionPoints(BoardEntity entity, ActionCostPreset cost)
        // we just change it for the current active player
        // even if that player might have selected some other unit, the whole frame would not be visible so it does not matter
        // the other player who is currently not ordering also cant have this action frame --> does not matter
        if entity.getBoard().isLocalPlayer()
            var ap = cost.getAP()
            if cost.isApFill()
                ap = 100
            updateActionPointsLocal(entity, ap)
    
    static function update(Player p)
        if p.isLocal() == false or p.isConntrolledByKI
            return

        if OrderSystem.couldOrderIFInteractable(p) == false
            hide()
            return
        let entity = p.currentSelectedEntity

        let currentAction = entity.getCurrentAction()

        for int i = 0 to primaryBtns.length - 1
            primaryBtns[i].setEmpty()

        for int i = 0 to secondaryBtns.length - 1
            secondaryBtns[i].setVisible(false)

            
        let actionItr = entity.getActions().iterator()

        var primaryIndex = 0
        var secondaryIndex = 0
        while actionItr.hasNext()
            let action = actionItr.next()
            if action.showAsPrimary()
                primaryBtns[primaryIndex].setAction(action, currentAction, PRIMARY_KEYS[primaryIndex])
                primaryIndex ++
            if action.showAsSecondary()
                secondaryBtns[secondaryIndex].setAction(action, currentAction, SECONDARY_KEYS[secondaryIndex])
                secondaryIndex ++
            
        destroy actionItr

        menu.setVisible(true)
        updateActionPointsLocal(entity, 0)

    static function hide(Player p)
        UIWindowSpellBook.close(p)
        if p.isLocal()
            hide()

    static function hide()
        menu.setVisible(false)