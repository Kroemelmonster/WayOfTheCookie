package KISystem

import ClosureTimers
import LinkedList

import BoardStack
import initlater Action
import initlater WaitAction
import initlater DefendAction
import BoardTrigger
import BoardEntity

public class KISystem
    static function getBestTarget(LinkedList<BoardStack> targets) returns BoardStack
        if targets.isEmpty()
            return null
        var maxWeight = 0.0
        for target in targets
            maxWeight += target.stats.getWeight()
        let weightedRandom = GetRandomReal(0, maxWeight)
        var currentWeight = 0.0
        BoardStack result = null
        let itr = targets.iterator()
        while itr.hasNext() and result == null
            let target = itr.next()
            currentWeight += target.stats.getWeight()
            if currentWeight >= weightedRandom
                result = target

        return result


    @inline
    protected static function isActionWait(Action action) returns boolean
        return action instanceof WaitAction

    @inline
    protected static function isActionDefend(Action action) returns boolean
        return action instanceof DefendAction

    @inline
    protected static function isActionSpecial(Action action) returns boolean
        return isActionWait(action) == false and isActionDefend(action) == false

    protected static function executeDefendOrSkipAction(BoardEntity entity)
        let itr = entity.getActions().iterator()
        Action defendOrSkipAction = null
        while itr.hasNext() and defendOrSkipAction == null
            let action = itr.next()
            if isActionDefend(action) and action.canActivate()
                defendOrSkipAction = action
        destroy itr
        defendOrSkipAction.activate()

    protected static function executeDefaultAction(BoardEntity entity)
        let defaultAction = entity.getDefaultAction()
        defaultAction.executeForKI() (status) ->
            if status == 1
                doAfter(0.2) ->
                    // there is litterly nothing you can doo ?
                    executeDefendOrSkipAction(entity)

    protected static function executeNextAction(LLIterator<Action> itr, BoardEntity entity, SequenzListenerStatus next)
        if itr.hasNext()
            let action = itr.next()
            if isActionSpecial(action) and action.canActivate()
                action.executeForKI() (int status) ->
                    if status == 1 // he did not do anything
                        executeNextAction(itr, entity, next)
                    else if status == 0
                        next.continue(1)
            else
                executeNextAction(itr, entity, next)
            
        else
            next.continue(0)

    static function executeTurn(BoardEntity entity)
        doAfter(0.2) ->
            let itr = entity.getActions().iterator()
            executeNextAction(itr, entity) (status) ->
                destroy itr
                if status == 0
                    executeDefaultAction(entity)