package Damage

import initlater BoardStack
import initlater BoardEntity

import KUtil
import Globals
import KStringUtils
import Tooltip
import BitSet

public enum SourceType
    ATTACK
    SPELL
    UNSPECIFIC

public enum DamageFlags
    DOT
    TRIGGERED

public enum DamageType
    PHYSICAL
    MAGIC
    FIRE
    POISON
    PURE

public abstract class Damage
    protected DamageType damageType
    protected bitset flags = bitset(8)
    protected SourceType sourceType

    static constant colorA array COLOR = [
        colorA(200, 200, 200, 200),
        colorA(43, 181, 245, 200),
        colorA(255, 120, 86, 200),
        colorA(167, 252, 71, 199),
        colorA(50, 0, 97, 199)
    ]

    construct(SourceType sourceType, DamageType damageType)
        this.damageType = damageType
        this.sourceType = sourceType

    function getType() returns DamageType
        return damageType

    function getSourceType() returns SourceType
        return sourceType

    function hasFlag(DamageFlags flag) returns boolean
        return flags.get(flag castTo int)

    function copyTo(Damage copy)
        copy.flags = this.flags

    static function type2Color(DamageType dType) returns string
        return COLOR[dType castTo int].toColorString()

public class DamageInstance extends Damage
    real dmg

    construct(real dmg, SourceType sourceType, DamageType damageType)
        super(sourceType, damageType)
        this.dmg = dmg

    function copy() returns DamageInstance
        let copy = new DamageInstance(this.dmg, this.sourceType, this.damageType)
        this.copyTo(copy)
        return copy

    function dealDamageTo(BoardEntity source, BoardStack target) returns SpecificDamageInstance
        return new SpecificDamageInstance(this, source, target)

public class DamagePreview extends Damage
    realRange dmg

    construct(SourceType sourceType, DamageType damageType)
        super(sourceType, damageType)
        this.dmg = realRange(0, 0)

    static function create(SourceType sourceType, DamageType damageType) returns DamagePreview
        return new DamagePreview(sourceType, damageType)

    function addFlag(DamageFlags flag)
        flags = flags.set(flag castTo int)

    function setDamage(realRange dmg)
        this.dmg = dmg

    function copy() returns DamagePreview
        let copy = new DamagePreview(this.sourceType, this.damageType)
        copy.dmg = this.dmg
        this.copyTo(copy)
        return copy
    
    function getRandomInstance() returns DamageInstance
        let instance = new DamageInstance(dmg.random(), sourceType, damageType)
        super.copyTo(instance)
        return instance

    function extendTooltipWithSpecific(Tooltip tooltip, BoardEntity source, BoardStack target)
        let preview = new SpecificDamagePreview(this, source, target)
        tooltip.addLine(KStringUtils.coloredString(target.getPlayer().toColor(), target.getName()))
        tooltip.addLine(KStringUtils.stat("Damage", Damage.type2Color(preview.damagePreview.damageType), preview.damage))
        tooltip.addLine(KStringUtils.stat("Kills", KStringUtils.COLOR_NEGATIVE, preview.amount))
        destroy preview

    function toColoredText() returns string
        return KStringUtils.coloredRange(Damage.type2Color(damageType), dmg.round())

public class SpecificDamageInstance
    protected int damage
    protected int kills
    protected DamageInstance damageInstance

    construct(DamageInstance baseDamage, BoardEntity source, BoardStack target)
        damageInstance = baseDamage.copy()
        let factor = calculateDamageFactor(source, damageInstance, target)
        damage = (damageInstance.dmg * factor).round()
        kills = calculateStackLostCount(target, damage)
        var remainingHp = target.stats.getHp()
        remainingHp += target.stats.getMaxHP() * kills
        remainingHp -= damage
        
        target.stats.addAmount(-kills)
        target.stats.setHp(remainingHp)

    function getDamage() returns int
        return damage

    function getKills() returns int
        return kills

    function getDamageData() returns Damage
        return damageInstance

    function getBaseDamage() returns int
        return damageInstance.dmg.round()

    function toColoredText() returns string
        var str = KStringUtils.coloredInt(Damage.type2Color(damageInstance.damageType), damage)
        if kills > 0
            str +=  "   " + KStringUtils.coloredInt(KStringUtils.COLOR_NEGATIVE, kills)
        return str 

    ondestroy
        destroy damageInstance

public class SpecificDamagePreview
    intRange damage
    intRange amount
    DamagePreview damagePreview

    construct(DamagePreview baseDamage, BoardEntity source, BoardStack target)
        damagePreview = baseDamage.copy()
        let factor = calculateDamageFactor(source, damagePreview, target)
        damage = (damagePreview.dmg * factor).round()
        amount.min = calculateStackLostCount(target, damage.min)
        amount.max = calculateStackLostCount(target, damage.max)

    ondestroy
        destroy damagePreview


public function calculateAttackVsDefencePercentage(int attack, int defence) returns real
    let difference = attack - defence

    if difference >= 0
        var posEffect = difference * DAMAGECALC_ATTACK_VS_DEFENCE_POSITIVE
        if posEffect > DAMAGECALC_ATTACK_VS_DEFENCE_POSITIVE_MAX
            posEffect = DAMAGECALC_ATTACK_VS_DEFENCE_POSITIVE_MAX
        return posEffect
    else
        var negativeEffect = difference * -1 * DAMAGECALC_ATTACK_VS_DEFENCE_NEGATIVE
        if negativeEffect < DAMAGECALC_ATTACK_VS_DEFENCE_NEGATIVE_MAX
            negativeEffect = DAMAGECALC_ATTACK_VS_DEFENCE_NEGATIVE_MAX
        return negativeEffect

function calculateDamageFactor(BoardEntity source, Damage dmg, BoardStack target) returns real
    let resistanceFactor = (1 - (target.stats.getResistance(dmg.damageType) / 100.0))
    if dmg.sourceType == ATTACK and source.getType() == EntityType.STACK
        let sourceAttacker = source.toStack()
        let attackFactor = (1 + calculateAttackVsDefencePercentage(sourceAttacker.stats.getAttack(), target.stats.getDefence()) / 100)
        return resistanceFactor * attackFactor
    // TODO here could be more triggers for calulating specific dmg
    return resistanceFactor


function calculateStackLostCount(BoardStack target, int damage) returns int
    var amount = 0
    let remainingDmg = damage - target.stats.getHp()
    if remainingDmg >= 0
        amount ++
        let maxHp = target.stats.getMaxHP()
        amount += (remainingDmg / maxHp).floor()
    
    if amount > target.stats.getAmount()
        amount = target.stats.getAmount()

    return amount



/*

    protected function getUnitLostCount(int dmg) returns int
        var amount = 0
        let remainingDmg = dmg - defender.stats.getHp()
        if remainingDmg >= 0
            amount ++
            let maxHp = defender.stats.getMaxHp()
            amount += (remainingDmg / maxHp).floor()
        
        if amount > defender.stats.getAmount()
            amount = defender.stats.getAmount()

        return amount

    function getOneResult() returns DamageResult
        var result = new DamageResult()
        result.damage = this.damage.random()
        result.amount = getUnitLostCount(result.damage)
        result.remainingHP = defender.stats.getHp()
        result.remainingHP += defender.stats.getMaxHp() * result.amount
        result.remainingHP -= result.damage

        result.baseDamage = this.baseDamage.copy()

        return result

    protected abstract function getBaseDamage() returns Damage

    /** should always return 100 if you dont want to change the damage at all **/
    /*
    protected abstract function getBaseEffectivness() returns real

    function calculate(BoardStack defender)
        this.defender = defender
        if baseDamage != null
            destroy baseDamage
        baseDamage = getBaseDamage()
        effectivness = getBaseEffectivness() * (1 - (defender.stats.getResistance(baseDamage.damageType) / 100.0))
        let realDamage = baseDamage.value * (effectivness / 100.0)
        damage.min = realDamage.min.round()
        damage.max = realDamage.max.round()
        amount.min = getUnitLostCount(damage.min)
        amount.max = getUnitLostCount(damage.max)
*/