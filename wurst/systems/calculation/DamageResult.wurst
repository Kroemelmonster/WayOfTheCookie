package DamageResult

import LinkedList

import KUtil
import UITooltip
import PassiveAction

import initlater BoardStack
import initlater Cell
import initlater StackType

public constant DAMAGECALC_ATTACK_VS_DEFENCE_POSITIVE = 5.0
public constant DAMAGECALC_ATTACK_VS_DEFENCE_POSITIVE_MAX = 300.0
public constant DAMAGECALC_ATTACK_VS_DEFENCE_NEGATIVE = -2.5
public constant DAMAGECALC_ATTACK_VS_DEFENCE_NEGATIVE_MAX = -70.0

public class DamageResult
    int damage
    int amount
    int remainingHP

    function toString() returns string
        return "DamageResult damage:"+damage.toString()+ ", amount:"+amount.toString()

    static function calulateOneAttackResult(BoardStack attacker, BoardStack defender) returns DamageResult
        let preview = new AttackResultPreview(attacker, false)
        preview.calculate(defender)
        let result = preview.getOneResult()
        destroy preview
        return result

public class Damage
    protected realRange value
    protected DamageType damageType

    construct(realRange value, DamageType damageType)
        this.value = value
        this.damageType = damageType


public abstract class DamageResultPreview
    protected BoardStack attacker
    protected BoardStack defender
    protected intRange amount
    protected intRange damage
    protected real effectivness

    construct(BoardStack attacker)
        this.attacker = attacker

    function getAmount() returns intRange
        return amount

    function getDamage() returns intRange
        return damage

    function addToTooltip(Tooltip tt)
        tt.addLine(Tooltip.playerColored(defender.getPlayer(), defender.getName()))
        tt.addLine(Tooltip.stat("Damage", damage))
        tt.addLine(Tooltip.stat("Kills", Tooltip.COLOR_NEGATIVE, amount))

    protected function getUnitLostCount(int dmg) returns int
        var amount = 0
        let remainingDmg = dmg - defender.stats.getHp()
        if remainingDmg >= 0
            amount ++
            let maxHp = defender.stats.getMaxHp()
            amount += (remainingDmg / maxHp).floor()
        
        if amount > defender.stats.getAmount()
            amount = defender.stats.getAmount()

        return amount

    function getOneResult() returns DamageResult
        var result = new DamageResult()
        result.damage = this.damage.random()
        result.amount = getUnitLostCount(result.damage)
        result.remainingHP = defender.stats.getHp()
        result.remainingHP += defender.stats.getMaxHp() * result.amount
        result.remainingHP -= result.damage

        return result

    protected abstract function getBaseDamage() returns Damage

    /** should always return 100 if you dont want to change the damage at all **/
    protected abstract function getBaseEffectivness() returns real

    function calculate(BoardStack defender)
        this.defender = defender
        let baseDamage = getBaseDamage()
        effectivness = getBaseEffectivness() * (1 - (defender.stats.getResistance(baseDamage.damageType) / 100.0))
        let realDamage = baseDamage.value * (effectivness / 100.0)
        damage.min = realDamage.min.round()
        damage.max = realDamage.max.round()
        amount.min = getUnitLostCount(damage.min)
        amount.max = getUnitLostCount(damage.max)
        destroy baseDamage
    
    function update(BoardStack defender)
        if this.defender != defender
            calculate(defender)

    function isEmpty() returns boolean
        return this.defender == null

    function reset()
        this.defender = null

public class AttackResultPreview extends DamageResultPreview
    private LinkedList<PassiveAction> counters

    construct(BoardStack attacker, boolean includeCounters)
        super(attacker)
        if includeCounters
            counters = new LinkedList<PassiveAction>

    protected override function getBaseDamage() returns Damage
        return new Damage(attacker.stats.getDamage(), attacker.stats.getDamageType())

    protected override function getBaseEffectivness() returns real
        let difference = attacker.stats.getAttack() - defender.stats.getDefence()

        if difference >= 0
            var posEffect = difference * DAMAGECALC_ATTACK_VS_DEFENCE_POSITIVE
            if posEffect > DAMAGECALC_ATTACK_VS_DEFENCE_POSITIVE_MAX
                posEffect = DAMAGECALC_ATTACK_VS_DEFENCE_POSITIVE_MAX
            return 100.0 + posEffect
        else
            var negativeEffect = difference * -1 * DAMAGECALC_ATTACK_VS_DEFENCE_NEGATIVE
            if negativeEffect < DAMAGECALC_ATTACK_VS_DEFENCE_NEGATIVE_MAX
                negativeEffect = DAMAGECALC_ATTACK_VS_DEFENCE_NEGATIVE_MAX
            return 100.0 + negativeEffect

    override function addToTooltip(Tooltip tt)
        super.addToTooltip(tt)
        if counters == null or counters.isEmpty()
            return
        var str = "Will Counter with "
        let itr = counters.iterator()
        while itr.hasNext()
            let counter = itr.next()
            str += counter.getName()
            if itr.hasNext()
                str += ", "
        tt.addLine(str)

    override function calculate(BoardStack defender)
        super.calculate(defender)
        if counters == null
            return
        counters.clear()
        let itr = defender.passiveActionIterator()
        while itr.hasNext()
            let passive = itr.next()
            if passive.triggerAfterAttackCheck(attacker, attacker.getCell())
                counters.add(passive)

        destroy itr

    function calculate(BoardStack defender, Cell fromCell)
        super.calculate(defender)
        if counters == null
            return
        counters.clear()
        let itr = defender.passiveActionIterator()
        while itr.hasNext()
            let passive = itr.next()
            if passive.triggerAfterAttackCheck(attacker, fromCell)
                counters.add(passive)

        destroy itr

    ondestroy
        if counters != null
            destroy counters

        
