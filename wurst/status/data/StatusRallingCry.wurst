package StatusRallingCry

import AttachmentPoints
import Abilities

import Status

import initlater BoardEntity
import initlater StatusType
import BoardTrigger
import Tooltip
import BoardStack
import SharedStatus

init
    Initializer.register(InitializerNames.STATI) -> 
        StatusRallingCry.setup()

public class StatusRallingCry extends SharedStatus
    static StatusType TYPE
    protected static function setup()
        TYPE = new StatusType("Rallying Cry", "Icons\\BTNAbilityWarriorWarCry.blp")
        TYPE.setCreationListener() (boardEntity, statusData) ->
            return new StatusRallingCry(TYPE, boardEntity, statusData)
        TYPE.setTooltipListener() data ->
            return createTooltipBaseLines(data)

    protected static constant int ATTACK_BONUS = 0

    protected static function createTooltipBaseLines(int attackValue) returns LinkedList<string>
        return new LinkedList<string>
        ..add("Increases the Attack by "
            + KStringUtils.coloredInt(KStringUtils.COLOR_POSITIVE, attackValue))

    protected static function createTooltipBaseLines(StatusData data) returns LinkedList<string>
        return createTooltipBaseLines(data.getIntData(ATTACK_BONUS))

    protected static function createTooltip(StatusRallingCry b) returns Tooltip
        return Tooltip.create(TYPE.getName())
        ..addLines(createTooltipBaseLines(b.attack))

    /* -------------------------------------------------------------------------- */

    protected BoardTrigger turnStartListener
    protected effect display
    protected int duration
    protected int attack = 0

    construct(StatusType statusType, BoardEntity entity, StatusData data)
        super(statusType, entity, data)

    protected override function setupPrimary(StatusData data)
        duration = data.duration

        let affectedAllies = data.getAllEntityData()
        let secondaryData = StatusData.create()
        ..setIntData(ATTACK_BONUS, attack)
        for ally in affectedAllies
            applySecondary(ally, secondaryData)
        destroy secondaryData

        turnStartListener = entity.getTriggers().addTurnStart() next ->
            duration--
            if duration <= 0
                removePrimary(next)
            else
                next.continue()

        attack = data.getIntData(ATTACK_BONUS)
        display = entity.addAttachEffect(Abilities.drumsCasterHeal, AttachmentPoints.origin)
        applyStats(true)

    protected override function setupSecondary(StatusData data)
        attack = data.getIntData(ATTACK_BONUS)
        display = entity.addAttachEffect(Abilities.drumsCasterHeal, AttachmentPoints.origin)
        applyStats(true)
        
    override function onRefresh(StatusData data)
        // we reject refreshs TODO maybe think about smth better

    override function canPurge() returns boolean
        return false

    protected function applyStats(boolean add)
        if isPrimary()
            applyStatsHero(add)
        else
            applyStatsStack(add)

    protected function applyStatsHero(boolean add)
        let multi = add ? 1 : -1
        entity.toHero().stats.attackModi.addBonus += attack * multi

    protected function applyStatsStack(boolean add)
        let multi = add ? 1 : -1
        entity.toStack().stats.attackModi.addBonus += attack * multi

    override function createTooltip() returns Tooltip
        return createTooltip(this)

    override function hide()
        if display != null
            display.destr()
            display = null

    ondestroy
        if entity.isAlive()
            applyStats(false)
            if turnStartListener != null
                entity.getTriggers().removeOnTurnStart(turnStartListener)
                turnStartListener = null