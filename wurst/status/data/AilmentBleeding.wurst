package AilmentBleeding

import AttachmentPoints
import Icons
import Abilities

import Status

import initlater BoardStack
import initlater StatusType
import initlater BoardController
import Damage
import KUtil
import StackType
import Cell
import BoardTrigger
import initlater DelayAnimation
import Ailment
import BoardEntity
import DamageAndResistance
import LinkedList
import Tooltip
import KStringUtils


/*

public class AilmentBleeding extends Status
    static StatusType TYPE

    static function setup()
        TYPE = new StatusType("Bleeding", "Icons\\PASBloodSprinkle.blp")
        TYPE.setCreationListener()(BoardEntity entity) ->
            return new AilmentBleeding(TYPE, entity)
        TYPE.setTooltipListener() (StatusData data) ->
            return createTooltipBaseLines(data)

    private static constant string EFFECT = "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodLarge0.mdl"
    private static constant DamagePreview damagePreview = DamagePreview.createDot(SourceType.UNSPECIFIC, DamageType.PHYISICAL, true)

    private static function createTooltipBaseLines(StatusData data) returns LinkedList<string>
        let lines = new LinkedList<string>
        ..add("Bleeding makes you suffer damage each turn")
        ..add("Each cell you move or get moved will trigger this damage again with an even greater value")
        if data != null
            destroy data
        return lines

    private static function createSpecificTooltip(AilmentBleeding b) returns Tooltip
        return Tooltip.create(TYPE.getName())
        ..addLine(KStringUtils.stat("Duration", b.stacks.getMaxDuration()))
        ..addLine(KStringUtils.stat("Stacks", b.stacks.size()))
        ..addLine("")
        ..addLine("You are currently bleeding and suffer "
         + b.calculateDamage(false).toColoredText()
         + " each turn")
        ..addLine("As well as "
         + b.calculateDamage(true).toColoredText()
         + " each time you attempt to move into another cell")

    static function flashEffect(BoardStack target)
        target.flashAttachEffect(EFFECT, AttachmentPoints.chest)

    private BoardTrigger turnStartListener
    private BoardTrigger turnEndListener
    private BoardTriggerOnAnyCellLeave moveListener

    private AilmentStacks stacks = new AilmentStacks()
    private BoardStack stack

    private function calculateDamage(boolean walking) returns DamagePreview
        var avg = stacks.getHighestDamage()
        if walking
            avg *= 2.0
        damagePreview.dmg = realRange(avg * 0.8, avg * 1.2)
        return damagePreview

    construct(StatusType statusType, BoardEntity entity)
        super(statusType, entity)
        stack = entity.toStack()

        let triggers = stack.getTriggers()

        moveListener = triggers.addOnAnyCellLeave() (BoardStack target, Cell fromCell, Cell toCell, SequenzListener next) ->
            if stack == target
                dealDamage(true) ->
                    next.continue()
            else
                next.continue()

        turnStartListener = triggers.addTurnStart() (SequenzListener next) ->
            dealDamage(false) ->
                next.continue()

        turnEndListener = triggers.addTurnEnd() (SequenzListener next) ->
            if stacks.removeOneDuration()
                kill()
            next.continue()

    @inline
    private static function getDamage(StatusData data) returns real
        return data.firstRealValue

    override protected function updateInner(StatusData data)
        stacks.add(data.duration, getDamage(data))

    override function createTooltip() returns Tooltip
        return createSpecificTooltip(this)

    override function hide()

    private function dealDamage(boolean walking, SequenzListener next)
        let board = stack.getBoard()
        DelayAnimation.create(board, 0.5) ->
            flashEffect(stack)
            let instance = calculateDamage(walking).getRandomInstance()
            BoardController.dealDamage(stack, instance, stack) ->
                destroy instance
                DelayAnimation.create(board, 0.3) ->
                    next.continue()
        //stack.stats.setActionPoints(stack.stats.getRemainingActionPoints() - 1)

    ondestroy
        stack.getTriggers()
            ..removeOnAnyCellLeave(moveListener)
            ..removeOnTurnEnd(turnEndListener)
            ..removeOnTurnStart(turnStartListener)
        destroy stacks

        */