package BleedingAilment

import AttachmentPoints
import Icons
import Abilities

import Status
import UITooltip

import initlater BoardStack
import initlater StatusType
import initlater BoardController
import Damage
import KUtil
import StackType
import Cell
import BoardTrigger
import initlater DelayAnimation
import Ailment
import BoardEntity

public class BleedingAilment extends Status
    private static constant string NAME = "Bleeding"
    private static constant string EFFECT = "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodLarge0.mdl"

    static function setup() returns StatusType
        let statusType = new StatusType("Icons\\PASBloodSprinkle.blp", NAME)
        statusType.setCreationListener()(BoardEntity entity) ->
            return new BleedingAilment(statusType, entity)
        statusType.setTooltipListener() (StatusData data) ->
            return createTooltip(null, data)

        return statusType

    private static constant DamagePreview damagePreview = createDamagePreview()
    
    private static function createDamagePreview() returns DamagePreview
        let preview = new DamagePreview(realRange(0, 0), SourceType.UNSPECIFIC, DamageType.PHYISICAL)
        preview.isDot = true
        preview.isTriggered = true
        return preview

    static function flashEffect(BoardStack target)
        target.flashAttachEffect(EFFECT, AttachmentPoints.chest)

    private BoardTrigger turnStartListener
    private BoardTrigger turnEndListener
    private BoardTriggerOnAnyCellLeave moveListener

    private AilmentStacks stacks = new AilmentStacks()
    private BoardStack stack

    private function calculateDamage(boolean walking)
        var avg = stacks.getHighestDamage()
        if walking
            avg *= 2.0
        damagePreview.dmg = realRange(avg * 0.8, avg * 1.2)

    construct(StatusType statusType, BoardEntity entity)
        super(statusType, entity)
        stack = entity.toStack()

        let triggers = stack.getTriggers()

        moveListener = triggers.addOnAnyCellLeave() (BoardStack target, Cell fromCell, Cell toCell, SequenzListener next) ->
            if stack == target
                dealDamage(true) ->
                    next.continue()
            else
                next.continue()

        turnStartListener = triggers.addTurnStart() (SequenzListener next) ->
            dealDamage(false) ->
                next.continue()

        turnEndListener = triggers.addTurnEnd() (SequenzListener next) ->
            if stacks.removeOneDuration()
                kill()
            next.continue()

    private static function createTooltip(BleedingAilment b, StatusData data) returns Tooltip
        let tooltip = Tooltip.create(NAME)
        if b == null
            tooltip.addLine("Bleeding makes you suffer damage each turn")
            tooltip.addLine("Each cell you move or get moved will trigger this damage again with an even greater value")
        else
            tooltip.addLine(Tooltip.stat("Duration", b.stacks.getMaxDuration()))
            tooltip.addLine(Tooltip.stat("Stacks", b.stacks.size()))
            tooltip.addLine("")
            b.calculateDamage(false)
            tooltip.addLine("You are currently bleeding and suffer "+Tooltip.coloredRange(Tooltip.damageType2Color(damagePreview.damageType), damagePreview.dmg.round())+ " each turn")
            b.calculateDamage(true)
            tooltip.addLine("As well as "+Tooltip.coloredRange(Tooltip.damageType2Color(damagePreview.damageType), damagePreview.dmg.round())+ " each time you attempt to move into another cell")
        
        // TODO do smth with statusdata
        if data != null
            destroy data
        return tooltip

    @inline
    private static function getDamage(StatusData data) returns real
        return data.firstRealValue

    override protected function updateInner(StatusData data)
        stacks.add(data.duration, getDamage(data))

    override function createCurrentTooltip() returns Tooltip
        return createTooltip(this, null)

    override function hide()

    private function dealDamage(boolean walking, SequenzListener next)
        let board = stack.getBoard()
        DelayAnimation.create(board, 0.5) ->
            flashEffect(stack)
            calculateDamage(walking)
            let instance = damagePreview.getRandomInstance()
            BoardController.dealDamage(stack, instance, stack) ->
                destroy instance
                DelayAnimation.create(board, 0.3) ->
                    next.continue()
        //stack.stats.setActionPoints(stack.stats.getRemainingActionPoints() - 1)

    ondestroy
        stack.getTriggers()
            ..removeOnAnyCellLeave(moveListener)
            ..removeOnTurnEnd(turnEndListener)
            ..removeOnTurnStart(turnStartListener)
        destroy stacks