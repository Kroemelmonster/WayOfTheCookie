package BleedingAilment

import AttachmentPoints
import Icons
import Abilities

import Status
import UITooltip

import initlater BoardStack
import initlater StatusType
import initlater BoardController
import Damage
import KUtil
import StackType
import Cell
import BoardTrigger
import LinkedList
import initlater DelayAnimation
import Ailment

public class BleedingAilment extends Status
    private static constant string NAME = "Bleeding"
    private static constant string EFFECT = "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodLarge0.mdl"

    static function setup() returns StatusType
        let statusType = new StatusType("Icons\\PASBloodSprinkle.blp", NAME, createTooltip(null))
        statusType.setCreationListener()(BoardStack stack) ->
            return new BleedingAilment(statusType, stack)

        return statusType

    private static constant DamagePreview damagePreview = createDamagePreview()
    
    @inline
    private static function createDamagePreview() returns DamagePreview
        let preview = new DamagePreview(realRange(0, 0), SourceType.UNSPECIFIC, DamageType.PHYISICAL)
        preview.isDot = true
        preview.isTriggered = true
        return preview

    static function flashEffect(BoardStack target)
        target.flashAttachEffect(EFFECT, AttachmentPoints.chest)

    private BoardTrigger turnStartListener
    private BoardTrigger turnEndListener
    private BoardTriggerOnAnyCellLeave moveListener

    private AilmentStacks stacks = new AilmentStacks()

    private function calculateDamage(boolean walking)
        var avg = stacks.getHighestDamage()
        if walking
            avg *= 2.0
        damagePreview.dmg = realRange(avg * 0.8, avg * 1.2)

    construct(StatusType statusType, BoardStack stack)
        super(statusType, stack)

        moveListener = stack.getTriggers().addOnAnyCellLeave() (BoardStack target, Cell fromCell, Cell toCell, SequenzListener next) ->
            if stack == target
                dealDamage(true) ->
                    next.continue()
            else
                next.continue()

        turnStartListener = stack.getTriggers().addTurnStart() (SequenzListener next) ->
            dealDamage(false) ->
                next.continue()

        turnEndListener = stack.getTriggers().addTurnEnd() (SequenzListener next) ->
            if stacks.removeOneDuration()
                kill()
            next.continue()

    private static function createTooltip(BleedingAilment b) returns Tooltip
        let tooltip = Tooltip.create(NAME)
        if b == null
            tooltip.addLine("Bleeding makes you suffer damage each turn")
            tooltip.addLine("Each cell you move or get moved will trigger this damage again with an even greater value")
        else
            tooltip.addLine(Tooltip.stat("Duration", b.stacks.getMaxDuration()))
            tooltip.addLine(Tooltip.stat("Stacks", b.stacks.size()))
            tooltip.addLine("")
            b.calculateDamage(false)
            tooltip.addLine("You are currently bleeding and suffer "+Tooltip.coloredRange(Tooltip.damageType2Color(damagePreview.damageType), damagePreview.dmg.round())+ " each turn")
            b.calculateDamage(true)
            tooltip.addLine("As well as "+Tooltip.coloredRange(Tooltip.damageType2Color(damagePreview.damageType), damagePreview.dmg.round())+ " each time you attempt to move into another cell")
        
        return tooltip

    override protected function updateInner(StatusData data)
        stacks.add(data.duration, data.realValue)

    override function createCurrentTooltip() returns Tooltip
        return createTooltip(this)

    override function hide()

    private function dealDamage(boolean walking, SequenzListener next)
        DelayAnimation.create(stack.getBoard(), 0.5) ->
            flashEffect(stack)
            calculateDamage(walking)
            let instance = damagePreview.getRandomInstance()
            BoardController.dealDamage(stack, instance, stack) ->
                destroy instance
                DelayAnimation.create(stack.getBoard(), 0.3) ->
                    next.continue()
        //stack.stats.setActionPoints(stack.stats.getRemainingActionPoints() - 1)

    ondestroy
        stack.getTriggers().removeOnAnyCellLeave(moveListener)
        stack.getTriggers().removeOnTurnEnd(turnEndListener)
        stack.getTriggers().removeOnTurnStart(turnStartListener)
        destroy stacks