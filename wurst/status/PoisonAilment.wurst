package PoisonAilment

import AttachmentPoints
import Status
import Icons
import UITooltip

import initlater BoardStack
import initlater StatusType
import initlater BoardController
import Damage
import KUtil
import StackType
import Cell
import BoardTrigger
import initlater DelayAnimation
import Ailment
import initlater BoardEntity

public class PoisonAilment extends Status
    private static constant string NAME = "Poison"
    private static constant string EFFECT = "Abilities\\Weapons\\PoisonArrow\\PoisonArrowMissile.mdl"

    static function setup() returns StatusType
        let statusType = new StatusType(Icons.bTNOrbOfVenom, NAME)
        statusType.setCreationListener()(BoardEntity entity) ->
            return new PoisonAilment(statusType, entity)
        statusType.setTooltipListener() (StatusData data) ->
            return createTooltip(null, data)

        return statusType

    private static constant DamagePreview damagePreview = createDamagePreview()
    
    @inline
    private static function createDamagePreview() returns DamagePreview
        let preview = new DamagePreview(realRange(0, 0), SourceType.UNSPECIFIC, DamageType.POISON)
        preview.isDot = true
        preview.isTriggered = true
        return preview

    static function flashEffect(BoardStack target)
        target.flashEffectOnPos(EFFECT)

    private BoardTrigger turnStartListener
    private BoardTrigger turnEndListener
    private BoardTriggerOnDamageTaken damageTakenListener

    private AilmentStacks stacks = new AilmentStacks()
    private BoardStack stack

    private function calculateDamage()
        let avg = stacks.getCombinedDamage()
        damagePreview.dmg = realRange(avg * 0.8, avg * 1.2)

    construct(StatusType statusType, BoardEntity entity)
        super(statusType, entity)
        stack = entity.toStack()

        damageTakenListener = stack.getTriggers().addOnDamageTaken() (BoardEntity source, BoardStack target, SpecificDamageInstance specificInstance, SequenzListener next) ->
            if specificInstance.damageInstance.isDot == false
                dealDamage() ->
                    next.continue()

        turnStartListener = stack.getTriggers().addTurnStart() (SequenzListener next) ->
            dealDamage() ->
                next.continue()

        turnEndListener = stack.getTriggers().addTurnEnd() (SequenzListener next) ->
            if stacks.removeOneDuration()
                kill()
            next.continue()

    private static function createTooltip(PoisonAilment b, StatusData data) returns Tooltip
        let tooltip = Tooltip.create(NAME)
        if b == null
            tooltip.addLine("Poisoned makes you suffer damage each turn")
            tooltip.addLine("Each time you take non-dot damage you also suffer this damage as well")
        else
            tooltip.addLine(Tooltip.stat("Duration", b.stacks.getMaxDuration()))
            tooltip.addLine(Tooltip.stat("Stacks", b.stacks.size()))
            tooltip.addLine("")
            b.calculateDamage()
            tooltip.addLine("You are currently poisoned and take " + Tooltip.coloredRange(Tooltip.damageType2Color(damagePreview.damageType), damagePreview.dmg.round()) + " each turn aswell as each time you take non-dot Damage")
    
        // TODO do smth with data
        if data != null
            destroy data
        return tooltip

    @inline
    private static function getDamage(StatusData data) returns real
        return data.firstRealValue

    override protected function updateInner(StatusData data)
        stacks.add(data.duration, getDamage(data))

    override protected function hide()

    override function createCurrentTooltip() returns Tooltip
        return createTooltip(this, null)

    private function dealDamage(SequenzListener next)
        DelayAnimation.create(stack.getBoard(), 0.5) ->
            flashEffect(stack)
            calculateDamage()
            let instance = damagePreview.getRandomInstance()
            BoardController.dealDamage(stack, instance, stack) ->
                destroy instance
                DelayAnimation.create(stack.getBoard(), 0.3) ->
                    next.continue()
        //stack.stats.setActionPoints(stack.stats.getRemainingActionPoints() - 1)

    ondestroy
        stack.getTriggers().removeOnDamageTaken(damageTakenListener)
        stack.getTriggers().removeOnTurnEnd(turnEndListener)
        stack.getTriggers().removeOnTurnStart(turnStartListener)
        destroy stacks