package PoisonAilment

import AttachmentPoints
import Buff
import Icons
import UITooltip

import initlater BoardStack
import initlater BuffType
import initlater BoardController
import Damage
import KUtil
import StackType
import Cell
import BoardTrigger
import initlater DelayAnimation
import Ailment

public class PoisonAilment extends Buff
    private static constant string NAME = "Poison"
    private static constant string EFFECT = "Abilities\\Weapons\\PoisonArrow\\PoisonArrowMissile.mdl"

    static function setup()
        BuffTypeSet.POISON = new BuffType(Icons.bTNOrbOfVenom, NAME, createTooltip(null)) (BoardStack stack) ->
            return new PoisonAilment(BuffTypeSet.POISON, stack)

    private static constant DamagePreview damagePreview = createDamagePreview()
    
    @inline
    private static function createDamagePreview() returns DamagePreview
        let preview = new DamagePreview(realRange(0, 0), SourceType.UNSPECIFIC, DamageType.POISON)
        preview.isDot = true
        preview.isTriggered = true
        return preview

    static function flashEffect(BoardStack target)
        target.flashEffectOnPos(EFFECT)

    private BoardTrigger turnStartListener
    private BoardTrigger turnEndListener
    private BoardTriggerOnDamageTaken damageTakenListener

    private AilmentStacks stacks = new AilmentStacks()

    private function calculateDamage()
        let avg = stacks.getCombinedDamage()
        damagePreview.dmg = realRange(avg * 0.8, avg * 1.2)

    construct(BuffType bType, BoardStack stack)
        super(bType, stack)

        damageTakenListener = stack.getTriggers().addOnDamageTaken() (BoardStack source, BoardStack target, SpecificDamageInstance specificInstance, SequenzListener next) ->
            if specificInstance.damageInstance.isDot == false
                dealDamage() ->
                    next.continue()

        turnStartListener = stack.getTriggers().addTurnStart() (SequenzListener next) ->
            dealDamage() ->
                next.continue()

        turnEndListener = stack.getTriggers().addTurnEnd() (SequenzListener next) ->
            if stacks.removeOneDuration()
                kill()
            next.continue()

    private static function createTooltip(PoisonAilment b) returns Tooltip
        let tooltip = Tooltip.create(NAME)
        if b == null
            tooltip.addLine("Poisoned makes you suffer damage each turn")
            tooltip.addLine("Each time you take non-dot damage you also suffer this damage as well")
        else
            tooltip.addLine(Tooltip.stat("Duration", b.stacks.getMaxDuration()))
            tooltip.addLine(Tooltip.stat("Stacks", b.stacks.size()))
            tooltip.addLine("")
            b.calculateDamage()
            tooltip.addLine("You are currently poisoned and take " + Tooltip.coloredRange(Tooltip.damageType2Color(damagePreview.damageType), damagePreview.dmg.round()) + " each turn aswell as each time you take non-dot Damage")
        
        return tooltip

    override protected function updateInner(BuffData data)
        stacks.add(data.duration, data.realValue)

    override protected function hide()

    override function createCurrentTooltip() returns Tooltip
        return createTooltip(this)

    private function dealDamage(SequenzListener next)
        DelayAnimation.create(stack.getBoard(), 0.5) ->
            flashEffect(stack)
            calculateDamage()
            let instance = damagePreview.getRandomInstance()
            BoardController.dealDamage(stack, instance, stack) ->
                destroy instance
                DelayAnimation.create(stack.getBoard(), 0.3) ->
                    next.continue()
        //stack.stats.setActionPoints(stack.stats.getRemainingActionPoints() - 1)

    ondestroy
        stack.getTriggers().removeOnDamageTaken(damageTakenListener)
        stack.getTriggers().removeOnTurnEnd(turnEndListener)
        stack.getTriggers().removeOnTurnStart(turnStartListener)
        destroy stacks