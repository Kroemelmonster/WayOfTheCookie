package BleedingAilment

import AttachmentPoints
import Icons
import Abilities

import Buff
import UITooltip

import initlater BoardStack
import initlater BuffType
import initlater BoardController
import Damage
import KUtil
import StackType
import Cell
import BoardTrigger
import LinkedList
import initlater DelayAnimation
import Ailment

public class BleedingAilment extends Buff
    private static constant string NAME = "Bleeding"
    private static constant string EFFECT = "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodLarge0.mdl"

    static function setup()
        BuffTypeSet.BLEEDING = new BuffType("Icons\\PASBloodSprinkle.blp", NAME, createTooltip(null)) (BoardStack stack) ->
            return new BleedingAilment(BuffTypeSet.BLEEDING, stack)

    private static constant DamagePreview damagePreview = createDamagePreview()
    
    @inline
    private static function createDamagePreview() returns DamagePreview
        let preview = new DamagePreview(realRange(0, 0), SourceType.UNSPECIFIC, DamageType.PHYISICAL)
        preview.isDot = true
        preview.isTriggered = true
        return preview

    private BoardTrigger turnStartListener
    private BoardTrigger turnEndListener
    private BoardTriggerOnAnyCellLeave moveListener

    private AilmentStacks stacks = new AilmentStacks()

    private function calculateDamage(boolean walking)
        var avg = stacks.getHighestDamage()
        if walking
            avg *= 2.0
        damagePreview.dmg = realRange(avg * 0.8, avg * 1.2)

    construct(BuffType bType, BoardStack stack)
        super(bType, stack)

        moveListener = stack.getTriggers().addOnAnyCellLeave() (BoardStack target, Cell fromCell, Cell toCell, SequenzListener next) ->
            if stack == target
                dealDamage(true) ->
                    next.continue()
            else
                next.continue()

        turnStartListener = stack.getTriggers().addTurnStart() (SequenzListener next) ->
            dealDamage(false) ->
                next.continue()

        turnEndListener = stack.getTriggers().addTurnEnd() (SequenzListener next) ->
            if stacks.removeOneDuration()
                kill()
            next.continue()

    private static function createTooltip(BleedingAilment b) returns Tooltip
        let tooltip = Tooltip.create(NAME)
        if b == null
            tooltip.addLine("This is bad you are bleeding ??")
        else
            tooltip.addLine(Tooltip.stat("Duration", b.stacks.getMaxDuration()))
            tooltip.addLine(Tooltip.stat("Stacks", b.stacks.size()))
            b.calculateDamage(false)
            tooltip.addLine("You are currently bleeding and suffer "+Tooltip.coloredRange(Tooltip.COLOR_NEGATIVE, damagePreview.dmg.round())+ " each turn")
            b.calculateDamage(true)
            tooltip.addLine("As well as "+Tooltip.coloredRange(Tooltip.COLOR_NEGATIVE, damagePreview.dmg.round())+ " each time you attempt to move into another cell")
        
        return tooltip

    override protected function updateInner(BuffData data)
        stacks.add(data.duration, data.realValue)

    override function createCurrentTooltip() returns Tooltip
        return createTooltip(this)

    override function hide()

    private function dealDamage(boolean walking, SequenzListener next)
        DelayAnimation.create(stack.getBoard(), 0.5) ->
            stack.flashAttachEffect(EFFECT, AttachmentPoints.chest)
            calculateDamage(walking)
            let instance = damagePreview.getRandomInstance()
            BoardController.dealDamage(stack, instance, stack) ->
                destroy instance
                DelayAnimation.create(stack.getBoard(), 0.3) ->
                    next.continue()
        //stack.stats.setActionPoints(stack.stats.getRemainingActionPoints() - 1)

    ondestroy
        stack.getTriggers().removeOnAnyCellLeave(moveListener)
        stack.getTriggers().removeOnTurnEnd(turnEndListener)
        stack.getTriggers().removeOnTurnStart(turnStartListener)
        destroy stacks