package Board


import LinkedList

import Cell
import BoardStack
import HexagonalGridUtil
import InitiativeList
import Animation
import Action
import UIController
import PlayerData
import KUtil
import HostileArmy
import Stack
import Hero
import StackType
import DummyRecycler
import ClosureTimers

public class Board
    private static Cell array allCells
    private static int offsetCells = 0

    protected int cols
    protected int rows

    private vec2 coord
    private rect area
    private int boundMin
    private int boundMax
    
    private Player p1
    private Player p2
    private Hero h1
    private Hero h2
    private HostileArmy hostileArmy
    private InitiativeList initiative
    private LinkedList<BoardStack> stacks = new LinkedList<BoardStack>()
    private LinkedList<BoardStack> graveyard = new LinkedList<BoardStack>()

    private Animation currentAnim
    private boolean isInteractAble = true
    private boolean shouldIDrawPlayer1
    private boolean shouldIDrawPlayer2

    
    private rect visibleArea
    private unit dummyCam
    private fogmodifier visibleModiPlayer1
    private fogmodifier visibleModiPlayer2

    construct(rect playArea, rect visibleArea)
        this.rows = (playArea.height() / VERTICAL_SPACING).floor()
        this.cols = (playArea.width() / WIDTH).floor()
        this.coord = playArea.getLeftBot()
        boundMin = offsetCells
        boundMax = offsetCells + cols * rows
        offsetCells += cols * rows
        for col = 0 to cols - 1 
            for row = 0 to rows - 1
                let h = hex(col, row)
                allCells[getIndex(h)] = new Cell(this, h)

        playArea.resize(coord, hex(cols, rows).toCoord() + coord)
        this.area = playArea
        this.visibleArea = visibleArea
        this.initiative = new InitiativeList(this)
        dummyCam = DummyRecycler.get(area.getCenter(), angle(0.0))
    
    @inline
    private function getIndex(hex hex) returns int
        return boundMin + hex.col * rows + hex.row

    @inline
    private function isInBounds(hex hex) returns boolean
        return hex.col >= 0 and hex.col < cols and hex.row >= 0 and hex.row < rows

    function getCell(hex hex) returns Cell
        if isInBounds(hex)
            return allCells[getIndex(hex)]
        return null

    function getCoord() returns vec2
        return coord
    
    function getInitiative() returns InitiativeList
        return initiative

    function getHero(int side) returns Hero
        if side == 0
            return h1
        return null
    
    function getHostileArmy() returns HostileArmy
        return hostileArmy

    function placeCombat(Hero hero, HostileArmy army)
        p1 = hero.getPlayer()
        p2 = army.getPlayer()
        h1 = hero
        hostileArmy = army
        placeArmy(hero.getArmy(), p1, true)
        placeArmy(army.getArmy(), p2, false)

        // TODO clear old visibilityModi.. and such
        visibleModiPlayer1 = createVision(p1.blzPlayer, visibleArea, false)
            ..start()
        visibleModiPlayer2 = createVision(p2.blzPlayer, visibleArea, false)
            ..start()
            
        p1.blzPlayer.setCameraTargetControllerNoZ(dummyCam, vec2(0.0, 0.0), false)
        p2.blzPlayer.setCameraTargetControllerNoZ(dummyCam, vec2(0.0, 0.0), false)
            
        UIController.triggerOnAnyStackCellChange(this)

    function endFight()
        initiative.reset()
        removePlayer(p1)
        removePlayer(p1)

        for stack in stacks
            destroy stack
        stacks.clear()
        
        for stack in graveyard
            destroy stack
        graveyard.clear()

    private function removePlayer(Player p)
        p.playingBoard = null

        visibleModiPlayer1.destr()


    private function placeArmy(Army army, Player p, boolean left)
        p.playingBoard = this

        let col = left ? 0 : cols - 1
        var row = (rows / 2).floor()
        var rowChange = 1
        
        for int i = 0 to Army.MAX_SIZE - 1
            let armyStack = army.getStack(i)
            if armyStack != null
                placeStack(new BoardStack(p, armyStack), hex(col, row))
            
                row += rowChange
                if rowChange > 0
                    rowChange += 1
                else
                    rowChange -= 1
                rowChange *= -1

    function getPlayerIndex(Player p) returns integer
        if this.p1 == p
            return 0
        else if this.p2 == p
            return 1
        return -1
    
    function getPlayer(int index) returns Player
        if index == 0
            return p1
        return p2

    function placeStack(BoardStack stack, hex pos)
        let cell = getCell(pos)
        if cell != null
            placeStack(stack, cell, false)

    function getCols() returns int
        return cols

    function getRows() returns int
        return rows

    function createSummon(Player p, StackType stackType, int amount) returns BoardStack
        ArmyStack armyStack = null
        if p == p1
            armyStack = h1.createSummon(stackType, amount)
        else if p == p2
            if h2 != null
                armyStack = h2.createSummon(stackType, amount)
            else
                armyStack = hostileArmy.createSummon(stackType, amount)

        if armyStack != null
            return new BoardStack(p, armyStack)
        return null

    function placeStack(BoardStack stack, Cell cell, boolean comeInHalfTheTime)
        cell.placeStack(stack)
        stacks.add(stack)
        initiative.addStack(stack, comeInHalfTheTime)

    function triggerOnStackKilled(BoardStack stack)
        stacks.remove(stack)
        initiative.removeStack(stack)
        graveyard.add(stack)

    function updateStackAfterTurnEnd()
        let itr = stacks.iterator()
        while itr.hasNext()
            let stack = itr.next()
            if stack.isOnBoard() == false
                itr.remove()
        destroy itr

    function forEachNeighbour(Cell startCell, LLItrClosure<Cell> itr)
        let cube = startCell.getHex().toCube()
        for int i = 0 to 5
            let cell = getCell((cube + CUBE_NEIGHBOURS[i]).toHex())
            if cell != null
                itr.run(cell)

        destroy itr

    @inline
    function forEachStack(LLItrClosure<BoardStack> itr)
        stacks.forEach(itr)

    /**
        Gives you a copy of all the stacks on the Board
        You are free to remove and kill anything on the board it will still link to the old stacks as if they were on the Board

        Just remeber to delete the List afterwards
    **/
    @inline
    function getAllStacks() returns LinkedList<BoardStack>
        return stacks.copy()
    
    function getNeighbour(Cell cell, int index) returns Cell
        let h = cell.getHex().getNeighbour(index)
        return getCell(h)

    function getNeighbourSecure(Cell cell, int index) returns Cell
        return getNeighbour(cell, ModuloInteger(index, 6))

    function getNeighbourIndex(Cell start, Cell other) returns int
        let startCube = start.getHex().toCube()
        let endCube = other.getHex().toCube()
        for int i = 0 to 5
            if startCube + CUBE_NEIGHBOURS[i] == endCube
                return i
        return -1

    function getDistanceTo(Cell cell, Cell otherCell) returns int
        let c1 = cell.getHex().toCube()
        let c2 = otherCell.getHex().toCube()
        return c1.distanceTo(c2)

    function eachCellInRangeIterator(Cell startCell, intRange r) returns CellRangeIterator
        return new CellRangeIterator(startCell, r)

    function forEachCellsInRange(Cell startCell, intRange r, LLItrClosure<Cell> itr)
        var cube = startCell.getHex().toCube()
        for int ring = 1 to r.max
            cube += CUBE_NEIGHBOURS[4]
            if ring >= r.min
                for int i = 0 to 5
                    for int i2 = 1 to ring
                        let cell = getCell(cube.toHex())
                        if cell != null
                            itr.run(cell)
                        cube += CUBE_NEIGHBOURS[i]
        destroy itr

    function getAllCellsInRange(Cell startCell, intRange r) returns LinkedList<Cell>
        let list = new LinkedList<Cell>()
        list.iterator()
        var cube = startCell.getHex().toCube()
        if r.min == 0
            list.add(startCell)
        for int ring = 1 to r.max
            cube += CUBE_NEIGHBOURS[4]
            if ring >= r.min
                for int i = 0 to 5
                    for int i2 = 1 to ring
                        let cell = getCell(cube.toHex())
                        if cell != null
                            list.add(cell)
                        cube += CUBE_NEIGHBOURS[i]
        return list

    function isLocalPlayer() returns boolean
        return p1.isLocal() or p2.isLocal()
            
    function startCombat()
        initiative.next()

    function setAnimation(Animation anim)
        this.currentAnim = anim

    function enableInteraction(boolean enable)
        this.isInteractAble = enable

    function isInteractAble() returns boolean
        return isInteractAble

    function tick(real delta)
        tickAnimation(delta)
        if shouldIDrawPlayer1
            shouldIDrawPlayer1 = false
            realDraw(p1)
        if shouldIDrawPlayer2
            shouldIDrawPlayer2 = false
            realDraw(p2)

        forEachStack() (BoardStack t) ->
            t.tick(delta)

    
    function tickAnimation(real delta)
        if currentAnim != null
            if currentAnim.tick(delta)
                if currentAnim != null
                    Animation.finishAnimation(currentAnim)
        
    function drawAll()
        draw(p1)
        draw(p2)

    function draw(Player p)
        if p == p1
            shouldIDrawPlayer1 = true
        if p == p2
            shouldIDrawPlayer2 = true
        
        
    function realDraw(Player p)
        if p.isLocal() == false or p.isConntrolledByKI
            return

        let currentStack = initiative.getCurrentStack()

        Action action = null
        Cell currentSelectedCell = null
        if p.currentSelectedStack != null
            currentSelectedCell = p.currentSelectedStack.getCell()

            if currentStack == p.currentSelectedStack and p == currentStack.getPlayer()
                action = p.currentSelectedStack.getCurrentAction()
            else
                action = p.currentSelectedStack.getDefaultAction()
        else if p.currentMousePosition.cell != null
            let stack = p.currentMousePosition.cell.getStack()
            if stack != null
                action = stack.getDefaultAction()

        
        let currentStackCell = currentStack.getCell()

        let canGiveOrders = p == currentStack.getPlayer() and p.currentSelectedStack == currentStack

        for int i = boundMin to boundMax - 1
            allCells[i].draw(p, action, canGiveOrders, currentStackCell, currentSelectedCell)

    
    function getCellBasedOnCoords(vec2 mouseCoord) returns Cell
        return getCell(coordToHex(mouseCoord - coord))

public class CellRangeIterator
    private Board board
    private cube cube
    private int ring
    private int i = 0
    private int i2 = 0
    private int maxRing
    private Cell nextCell

    construct(Cell startCell, intRange range)
        board = startCell.getBoard()
        ring = range.min
        maxRing = range.max
        cube = startCell.getHex().toCube()

        if range.min > 0
            // move out
            for int ringI = 1 to range.min
                cube += CUBE_NEIGHBOURS[4]
            next()

        else
            nextCell = startCell

    function hasNext() returns boolean
        return nextCell != null

    private function getNext() returns Cell
        i2++
        if i2 > ring
            i2 = 1
            i++
            if i > 5
                i = 0
                ring ++
                cube += CUBE_NEIGHBOURS[4]

        cube += CUBE_NEIGHBOURS[i]
        return board.getCell(cube.toHex())

    function next() returns Cell
        let savedNextCell = nextCell
        nextCell = null
        while ring <= maxRing and nextCell == null
            nextCell = getNext()
        if ring > maxRing
            nextCell = null
        return savedNextCell