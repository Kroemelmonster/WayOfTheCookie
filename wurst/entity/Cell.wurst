package Cell

import LinkedList

import HexagonalGridUtil
import BoardStack
import PlayerData
import Action
import KUtil

import initlater Board

public enum CellResult
    NONE
    PREVIEW
    PREVIEW_MINOR
    POSITIVE
    NEGATIVE
    NEUTRAL

public class Cell
    private static constant MODEL_FILE_INNER = "HexicModularInner.mdl"
    private static constant MODEL_FILE_OUTER = "HexicModularOuter.mdl"
    
    private static constant color array INNER_CELL_RESULT_COLOR = [
        color(20, 20, 20),
        color(136, 136, 136),
        color(70, 70, 70),
        color(20, 200, 20),
        color(200, 20, 20),
        color(255, 218, 53)
    ]

    private static constant OUTER_DEFAULT_COLOR = color(255, 255, 255)
    private static constant OUTER_ALPHA = 90
    

    private vec2 center
    private effect innerModel
    private effect outerModel
    private Board board
    private hex hex
    private BoardStack stack

    private texttag test

    construct(Board board, hex hex)
        this.board = board
        this.hex = hex
        this.center = hex.toCoord() + board.getCoord()

        let z = center.getTerrainZ()
        
        this.innerModel = addEffect(MODEL_FILE_INNER, vec3(center.x, center.y, z + 7))
        ..setColor(INNER_CELL_RESULT_COLOR[0])
        ..setScale(SCALING)

        this.outerModel = addEffect(MODEL_FILE_OUTER, vec3(center.x, center.y, z + 8))
        ..setColor(OUTER_DEFAULT_COLOR)
        ..setAlpha(OUTER_ALPHA)
        ..setScale(SCALING)

        // test = createTTEx(vec3(center.x, center.y, z - 5), "?", 13)

    /** GETTER / SETTER **/
    function getHex() returns hex
        return hex

    function getCoord() returns vec2
        return center
    
    function getBoard() returns Board
        return board
    
    // TODO this should be entity
    function getStack() returns BoardStack
        return stack

    /** FUNCTIONALS **/
    function removeStack()
        this.stack = null
        this.outerModel.setColor(OUTER_DEFAULT_COLOR)
    
    function setStack(BoardStack stack)
        this.stack = stack
        this.outerModel.setColor(stack.getPlayer().c)

    function placeStack(BoardStack stack)
        setStack(stack)
        stack.place(this)

    function eachCellInRangeIterator(intRange r) returns CellRangeIterator
        return board.eachCellInRangeIterator(this, r)

    function forEachCellsInRange(intRange r, LLItrClosure<Cell> itr)
        board.forEachCellsInRange(this, r, itr)

    function getAllCellsInRange(intRange r) returns LinkedList<Cell>
        return board.getAllCellsInRange(this, r)

    function forEachNeighbour(LLItrClosure<Cell> itr)
        board.forEachNeighbour(this, itr)

    function getNeighbour(int index) returns Cell
        return board.getNeighbour(this, index)

    function getNeighbourSecure(int index) returns Cell
        return board.getNeighbourSecure(this, index)

    function getNeighbourIndex(Cell otherCell) returns int
        return board.getNeighbourIndex(this, otherCell)

    function getDistanceTo(Cell otherCell) returns int
        return board.getDistanceTo(this, otherCell)
    
    function toString() returns string
        return hex.toString()

    /**  VISUALS  **/
     // ! this method is already behind localPlayer
    function draw(Player p, Action action, boolean canGiveOrders, Cell currentSelectedCell)
        var innerColor = INNER_CELL_RESULT_COLOR[0]
        var alpha = 100

        
        /*
        let entity = p.currentSelectedEntity
        if entity != null 
            let path = entity.getPathToCell(this)
            if path != null
                var text = ""
                if path.getCost() > 100
                    text = "# "
                let prev = path.getPrev()
                if prev != null
                    text += prev.getHex().col.toString() + " | " + prev.getHex().row.toString()
                test.setText(text, 13)
            else
                test.setText("--", 13)
        else
            test.setText("NA", 13)
            */
            

        
        if action != null
            var cellResult = CellResult.NONE
            if canGiveOrders
                cellResult = action.getHighlightResultForCell(p, this)
            if cellResult == CellResult.NONE
                cellResult = action.getPreviewResultForCell(this)

            innerColor = INNER_CELL_RESULT_COLOR[cellResult castTo int]
        
        
        if this == p.currentMousePosition.cell or this == currentSelectedCell
            alpha += 100

        innerModel.setColor(innerColor)
        innerModel.setAlpha(alpha)
