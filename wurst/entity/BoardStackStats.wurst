package BoardStackStats

import KUtil
import StatsModifier

import initlater BoardStack
import StackStats
import StackType
import initlater SubTargetList
import LinkedList
import initlater Cell
import DamageType

public class BoardStackStats
    private StackStats basis
    private BoardStack stack
    int startAmount
    int amount
    int remainingActionPoints
    int remainingMoveActionPoints
    int hp

    StatsModifier attackModi = new StatsModifier()
    StatsModifier defenceModi = new StatsModifier()
    StatsModifier damageModi = new StatsModifier()
    StatsModifier initModi = new StatsModifier()
    StatsModifier hpModi = new StatsModifier()
    StatsModifier actionPointModi = new StatsModifier()
    StatsModifier moveActionPointModi = new StatsModifier()
    private StatsModifier resultingMoveActionPointModi = new StatsModifier()

    int moveCoefficient = 100
    private Resistance resistance = new Resistance()


    private SubTargetList subAttackList = null

    construct(BoardStack stack, StackStats basis, int amount)
        this.basis = basis
        this.startAmount = amount
        this.amount = amount
        this.hp = basis.getMaxHP()
        this.stack = stack

        /*
        setSubAttackTarget() (Cell reference, BoardStack mainTarget) ->
            let list = new LinkedList<SubTarget>()
            let itr = mainTarget.getCell().eachCellInRangeIterator(intRange(1, 1))
            while itr.hasNext()
                let possibleTarget = itr.next().getStack()
                if possibleTarget != null and mainTarget.isEnemy(possibleTarget) == false
                    list.add(new SubTarget(possibleTarget, 0.5))

            destroy itr
            return list
        */

    function getBasis() returns StackStats
        return basis
    
    @inline
    function getInitiative() returns int
        return initModi.get(basis.getInitiative()).round()

    @inline
    function getMaxActionPoints() returns int
        return actionPointModi.get(basis.getMaxAP()).round()

    @inline
    function getMaxMoveActionPoints() returns int
        resultingMoveActionPointModi.addBonus = moveActionPointModi.addBonus + actionPointModi.addBonus
        resultingMoveActionPointModi.multi = moveActionPointModi.multi + actionPointModi.multi - 100
        return resultingMoveActionPointModi.get(basis.getMaxMoveAP()).round()
    
    @inline
    function getMaxHp() returns int
        return hpModi.get(basis.getMaxHP()).round()

    @inline
    function getDamage() returns realRange
        return damageModi.getRealRange(basis.getDamage(), amount)

    @inline
    function getDamageOne() returns realRange
        return damageModi.getRealRange(basis.getDamage(), 1)

    @inline
    function getAttackRange() returns intRange
        return basis.getRange()

    @inline
    function getAttack() returns int
        return attackModi.get(basis.getAttack()).round()

    @inline
    function getDefence() returns int
        return defenceModi.get(basis.getDefence()).round()

    @inline
    function getDamageType() returns DamageType
        return basis.stackType.damageType

    @inline
    function getResistance(DamageType dType) returns int
        return basis.getResistance(dType) + resistance.getRes(dType)

    @inline
    function getRemainingActionPoints() returns integer
        return remainingActionPoints

    @inline
    function getRemainingMoveActionPoints() returns integer
        return remainingMoveActionPoints

    @inline
    function getAmount() returns int
        return amount
    
    @inline
    function getHp() returns int
        return hp

    @inline
    function getStartAmount() returns int
        return startAmount

    @inline
    function getWeight() returns real
        return basis.getWeight()
    
    /** setters  **/

    @inline
    function setHp(int i)
        hp = i
        stack.setVisualHp(hp / getMaxHp())

    @inline
    function removeAP(integer amount)
        remainingActionPoints -= amount
        if remainingActionPoints < 0
            remainingActionPoints = 0
        remainingMoveActionPoints -= amount
        if remainingMoveActionPoints < 0
            remainingMoveActionPoints = 0

    function adjustRemainingActionPointsToRemainingMoveActionPoints(integer amount)
        if remainingActionPoints <= remainingMoveActionPoints
            if amount < remainingActionPoints
                remainingActionPoints = amount
        else
            remainingActionPoints = remainingActionPoints - (remainingMoveActionPoints - amount)
        remainingMoveActionPoints = amount

    @inline
    function addAmount(int i)
        amount += i

    @inline
    function resetActionPoints()
        remainingActionPoints = getMaxActionPoints()
        remainingMoveActionPoints = getMaxMoveActionPoints()

    @inline
    function setSubAttackTarget(SubTargetList list)
        subAttackList = list

    @inline
    function getSubAttackTargets(Cell reference, BoardStack mainTarget) returns LinkedList<SubTarget>
        if subAttackList != null
            return subAttackList.calculate(reference, mainTarget)
        return null

    ondestroy
        destroy attackModi
        destroy defenceModi
        destroy damageModi
        destroy initModi
        destroy actionPointModi
        destroy moveActionPointModi
        destroy resultingMoveActionPointModi
        destroy hpModi
        if subAttackList != null
            destroy subAttackList
            subAttackList = null