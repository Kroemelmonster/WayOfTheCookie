package InitiativeList

import LinkedList

import BoardStack
import BoardController

import initlater Board
import BoardHero
import PlayerData
import Hero
import UIInitiativeWindow
import BoardEntity

class InitiativeEntity
    protected BoardEntity boardEntity = null

    protected int initiative = 0
    protected int expiredTime = 0
    protected boolean didWait = false

    @inline
    function getBoardEntity() returns BoardEntity
        return boardEntity

    @inline
    function isWaiting() returns boolean
        return didWait

    @inline
    function getPlayer() returns Player
        return boardEntity.getPlayer()

    @inline
    function getIcon() returns string
        return boardEntity.getIcon()

    function toString() returns string
        return "Entity[ stack: "+boardEntity.toString()+" ]"

    function update()
        this.initiative = InitiativeList.initiativeToTime(boardEntity.getInitiative())

public class InitiativeEntry
    protected InitiativeEntity entity
    protected int time

    construct(InitiativeEntity entity, int time)
        this.entity = entity
        this.time = time

    @inline
    function getEnitity() returns InitiativeEntity
        return entity

    @inline
    function getTime() returns int
        return InitiativeList.timeToDisplayTime(time)

    function compare(InitiativeEntry other) returns int
        if this == other
            return 0
        if time > other.time
            return 1
        else if time < other.time
            return -1
        
        let normalResult = compareInner(other)
        // when you did wait you did decide to come after a slower unit
        if normalResult == 1
            if entity.didWait
                return -1
            else
                return 1
        else
            if other.entity.didWait
                return 1
            else
                return -1

    private function compareInner(InitiativeEntry other) returns int
        if entity.initiative > other.entity.initiative
            return 1
        else if entity.initiative < other.entity.initiative
            return -1
        else
            let id = entity castTo int
            let otherId = other.entity castTo int
            if id > otherId
                return 1
            else
                return -1

    function toString() returns string
        return "Entry[ time: "+time.toString()+" entity: "+entity.toString()+"]"


public class InitiativeList
    private static constant int ONE_ROUND = 100000
    private static constant int DISPLAY_TIME_FACTOR = 100
    // Show at minimum the very first 2 turn
    private static constant int MAX_TIME = ONE_ROUND * 2

    private LinkedList<InitiativeEntity> entities = new LinkedList<InitiativeEntity>
    private LinkedList<InitiativeEntry> entries = new LinkedList<InitiativeEntry>
    private Board board

    private int time = 0
    private InitiativeEntity current = null

    
    construct(Board board)
        this.board = board

    function addHeroInitital(BoardHero hero)
        let entity = new InitiativeEntity()
        entity.boardEntity = hero
        entity.update()
        entities.add(entity)

    function addStackInitial(BoardStack stack)
        let entity = new InitiativeEntity()
        entity.boardEntity = stack
        entity.update()
        entities.add(entity)

    function addSummon(BoardStack stack)
        let entity = new InitiativeEntity()
        entity.boardEntity = stack
        entity.update()
        entity.expiredTime = (entity.initiative * 0.5).round()
        entities.add(entity)
        update()

    function getEntity(BoardEntity searchEntity) returns InitiativeEntity
        InitiativeEntity found = null
        for entity in entities
            if entity.boardEntity == searchEntity
                found = entity

        return found

    function removeStack(BoardStack stack)
        let entity = getEntity(stack)
        if entity != null
            entities.remove(entity)

    function update()
        update(0, true)

    private function update(int elapsedTime, boolean updateUI)
        //Log.trace("update with "+elapsedTime.toString())
        for entry in entries
            destroy entry
        entries.clear()

        for entity in entities
            entity.expiredTime += elapsedTime
            entity.update()
            insertEntities(entity)

        //Log.trace("result : ")
        //for entry in entries
            //Log.trace(entry.toString())
        if updateUI
            UIInitiativeWindow.refresh(this)
        
        
    private function insertEntities(InitiativeEntity entity)
        var entryTime = 0 - entity.expiredTime
        //Log.trace("we want to add an entity : "+entity.toString())
        //Log.trace("at : "+entryTime.toString()+ " with an init of "+entity.initiative.toString())
        
        while entryTime < MAX_TIME
            entryTime += entity.initiative
            //Log.trace("put one entry at : "+entryTime.toString())
            
            let entry = new InitiativeEntry(entity, time + entryTime)
            // insert at sorted Place
            var i = 0
            while i < entries.size() and entry.compare(entries.get(i)) > 0
                i++
            entries.addAt(entry, i)

    function isFirstTurn() returns boolean
        return current == null

    function getBoard() returns Board
        return board
    
    function getCurrent() returns InitiativeEntity
        return current
    
    function iterator() returns LLIterator<InitiativeEntry>
        return entries.iterator()

    function get(int index) returns InitiativeEntry
        return entries.get(index)

    function reset()
        time = 0
        current = null
        for entry in entries
            destroy entry
        entries.clear()

        for entity in entities
            destroy entity
        entities.clear()


    /** Goes to the next Entry
        
        If this is the very first turn it will not change the entrys,
        this is because at the very first turn the currentTime is not at the first entrys time

        This Method will also refresh the UI and force the current Player to select the Stack
    **/
    function next()
        endTurn(false)

    /** same as next but with a waittime **/
    function wait()
        endTurn(true)

    function pushEntity(BoardEntity entity, int displayTime)
        let initEntity = getEntity(entity)
        if initEntity != null
            initEntity.expiredTime -= displayTimeToTime(displayTime)
            update()
    
    private function endTurn(boolean wait)
        //Log.trace("end Turn "+wait.toString())
        if current != null
            if wait
                current.expiredTime = (current.initiative * 0.5).round()
                current.didWait = true
            else
                current.didWait = false
            if current.boardEntity != null
                //Log.trace("trigger Turn end: "+current.boardEntity.toString())
                BoardController.onTurnEnd(current.boardEntity, wait) ->
                    advanceTurn()
            else
                advanceTurn()
        else
            advanceTurn()

    private function advanceTurn()
        let next = entries.getFirst()
        var elapsedTime = next.time - time
        if elapsedTime < 0
            elapsedTime = 0
        //Log.trace("we figured that the next dude is "+next.toString()+" so we advance time by "+elapsedTime.toString())
        update(elapsedTime, false)

      

        let currentEntry = entries.getFirst()
        //Log.trace("now current is : "+currentEntry.toString())
        entries.remove(currentEntry)
        current = currentEntry.entity
        current.expiredTime = 0
        destroy currentEntry

        if current.boardEntity != null
            //Log.trace("trigger turn start : "+current.boardEntity.toString())
            BoardController.onTurnStart(current.boardEntity, current.isWaiting())

        UIInitiativeWindow.refresh(this)
        

    @inline
    protected static function initiativeToTime(int initivative) returns int
        return (ONE_ROUND / ((initivative / 10.0) + 1.0)).round()

    @inline
    static function intiativeToDisplayTime(int initiative) returns int
        return timeToDisplayTime(initiativeToTime(initiative))

    @inline
    static function timeToDisplayTime(real time) returns int
        return (time / DISPLAY_TIME_FACTOR).round()

    @inline
    static function timeToDisplayTime(int time) returns int
        return (time / DISPLAY_TIME_FACTOR).round()

    @inline
    protected static function displayTimeToTime(int displayTime) returns int
        return displayTime * DISPLAY_TIME_FACTOR