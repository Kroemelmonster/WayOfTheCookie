package BoardController

import ClosureTimers

import KISystem
import BuffController

import initlater BoardStack
import initlater Cell
import initlater UIController
import initlater Board
import initlater Damage
import initlater StandardTextTags
import initlater Action
import initlater OrderSystem
import LinkedList
import BoardTrigger
import UITooltip
import StackType
import initlater MainController

constant TEXTTAG_COLOR_KILLS = colorA(250, 57, 57, 199).toColorString()

public class BoardController
    static function pushInitiative(BoardStack stack, real time)
        stack.getBoard().getInitiative().push(stack, time)
        UIController.triggerOnStackAmountChange(stack)


    /** Use this to summon / create a Stack mid Fight */
    static function placeStackOnBoard(BoardStack stack, Cell cell, SequenzListener next)
        let board = cell.getBoard()
        nullTimer() ->  
            board.placeStack(stack, cell, true)
            UIController.triggerOnStackCreationOrDeathChange(board)
            onCellEnter(stack, cell, cell, next)

    static function killStack(BoardStack stack, SequenzListener next)
        let board = stack.getBoard()
        nullTimer() ->  
            BuffController.hideAllBuffs(stack)
            stack.kill()
            UIController.triggerOnStackCreationOrDeathChange(board)
            next.continue()

    static function finishOrder(BoardStack stack, boolean isAllowedToContinue)
        let board = stack.getBoard()
        OrderSystem.endOrder(board)
        if stack.isAlive()
            if isAllowedToContinue and stack.canStillAct()
                stack.resetCurrentSelectedAction()
                UIController.triggerOnActionPointChange(stack)
                if stack.getPlayer().isConntrolledByKI
                    KISystem.executeTurn(stack)
            else
                stack.stats.resetActionPoints()
                board.getInitiative().next()
        else
            board.getInitiative().next()

    private static function dealDamageContinue(SpecificDamageInstance specificInstance, SequenzListener next)
        destroy specificInstance
        next.continue()

    static function dealDamage(BoardStack source, DamageInstance instance, BoardStack target, SequenzListener next)
        let specificInstance = instance.getSpecific(source, target)
        if target.stats.getAmount() <= 0
            dealDamageContinue(specificInstance, next)
            return
        let coord = target.getCell().getCoord()
        
        standardTextTag(coord, Tooltip.coloredSpecificDamageInstance(specificInstance))
        target.stats.addAmount(-specificInstance.amount)
        
        if target.stats.getAmount() == 0
            if specificInstance.damageInstance.isTriggered
                destroy specificInstance
                killStack(target, next)
            else
                onDamageTaken(source, target, specificInstance) ->
                    onDamageDealt(source, target, specificInstance) ->
                        destroy specificInstance
                        killStack(target, next)
        else
            target.stats.setHp(specificInstance.remainingHp)
            if specificInstance.amount > 0
                UIController.triggerOnStackAmountChange(target)

            if specificInstance.damageInstance.isTriggered
                dealDamageContinue(specificInstance, next)
            else
                onDamageTaken(source, target, specificInstance) ->
                    onDamageDealt(source, target, specificInstance) ->
                        dealDamageContinue(specificInstance, next)

    
    /** triggers **/

    static function onDamageDealt(BoardStack source, BoardStack target, SpecificDamageInstance specificInstance, SequenzListener next)
        source.getTriggers().triggerOnDamageDealt(source, target, specificInstance) ->
            next.continue()
    
    static function onDamageTaken(BoardStack source, BoardStack target, SpecificDamageInstance specificInstance, SequenzListener next)
        target.getTriggers().triggerOnDamageTaken(source, target, specificInstance) ->
            next.continue()

    static function onAttackEnd(BoardStack attacker, BoardStack defender, SequenzListener next)
        nullTimer() ->
            defender.getTriggers().triggerOnAttacked(attacker, defender) ->
                next.continue()

    static function onTurnEnd(BoardStack stack, boolean isWaiting, SequenzListener next)
        UIController.onTurnEnd(stack)
        
        if isWaiting == false and stack.isAlive()
            stack.forEachAction() (Action action) ->
                action.tickCooldown()
            stack.getTriggers().triggerOnTurnEnd() ->
                next.continue()
        else
            next.continue()

    private static function turnStartContinue(BoardStack stack)
        stack.setHighlight(true)
        stack.resetCurrentSelectedAction()
        UIController.onTurnStart(stack)

        if stack.getPlayer().isConntrolledByKI
            KISystem.executeTurn(stack)
            
        
    private static function getWonnedSide(Board board) returns int
        var sideWon = -2
        let list = board.getAllStacks()
        let itr = list.iterator()
        while itr.hasNext() and sideWon != -1
            let stack = itr.next()
            let side = board.getPlayerIndex(stack.getPlayer())
            if sideWon == -2
                sideWon = side
            else if sideWon != side
                sideWon = -1

        destroy itr
        destroy list
        return sideWon

    static function onTurnStart(BoardStack stack, boolean wasWaiting)
        nullTimer() ->
            let board = stack.getBoard()
            let side = getWonnedSide(board)
            if side == -1
                if wasWaiting
                    turnStartContinue(stack)
                else
                    stack.getTriggers().triggerOnTurnStart() ->
                        if stack.isAlive() and stack.canStillAct()
                            turnStartContinue(stack)
                        else
                            board.getInitiative().next()
            else
                MainController.endFight(board, side)
                    

    private static function onCellLeaveForAllStacks(LLIterator<BoardStack> stackItr, BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        if stackItr.hasNext()
            let current = stackItr.next()
            current.getTriggers().triggerOnAnyCellLeave(stack, fromCell, toCell) -> 
                onCellLeaveForAllStacks(stackItr, stack, fromCell, toCell, next)
        else
            next.continue()
                

    static function onCellLeave(BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        let board = stack.getBoard()
        let copy = board.getAllStacks()
        let stackItr = copy.iterator()
        onCellLeaveForAllStacks(stackItr, stack, fromCell, toCell) () ->
            destroy stackItr
            destroy copy
            next.continue()

            
    private static function onCellEnterForAllStacks(LLIterator<BoardStack> stackItr, BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        if stackItr.hasNext()
            let current = stackItr.next()
            current.getTriggers().triggerOnAnyCellEnter(stack, fromCell, toCell) -> 
                onCellEnterForAllStacks(stackItr, stack, fromCell, toCell, next)
        else
            next.continue()
                

    static function onCellEnter(BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        let board = stack.getBoard()
        let copy = board.getAllStacks()
        let stackItr = copy.iterator()
        onCellEnterForAllStacks(stackItr, stack, fromCell, toCell) () ->
            destroy stackItr
            destroy copy
            next.continue()