package BoardController

import ClosureTimers

import KISystem
import StatusController

import initlater BoardStack
import initlater Cell
import initlater UIController
import initlater Board
import initlater Damage
import initlater StandardTextTags
import initlater Action
import initlater OrderSystem
import LinkedList
import BoardTrigger
import UITooltip
import initlater MainController
import BoardEntity
import Globals
import Status
import StatusType
import StunDebuff

constant TEXTTAG_COLOR_KILLS = colorA(250, 57, 57, 199).toColorString()

public class BoardController

    static function stunEntity(BoardEntity _source, BoardEntity target, int time, SequenzListener next)
        if target.isAlive() == false
            next.continue()
            return

        let board = target.getBoard()
        board.getInitiative().pushEntity(target, time)
        if target.getType() == EntityType.STACK
            StatusController.add(StunDebuff.TYPE, target castTo BoardStack, StatusData.createDuration(1))
        next.continue()

    /** Use this to summon / create a Stack mid Fight */
    static function placeStackOnBoard(BoardStack stack, Cell cell, boolean isSummoned, SequenzListener next)
        let board = cell.getBoard()
        nullTimer() ->  
            board.placeStack(stack, cell, isSummoned)
            onCellEnter(stack, cell, cell, next)

    static function killStack(BoardStack stack, SequenzListener next)
        let board = stack.getBoard()
        nullTimer() ->  
            StatusController.hideAll(stack)
            stack.kill()
            UIController.triggerOnStackCreationOrDeathChange(board) -> 
                next.continue()

    static function finishOrder(BoardEntity entity, boolean isAllowedToContinue)
        let board = entity.getBoard()
        OrderSystem.endOrder(board)
        if entity.isAlive()
            if isAllowedToContinue and entity.canStillAct()
                entity.resetCurrentSelectedAction()
                UIController.triggerOnActiveEntityActionPointChange(entity)
                if entity.getPlayer().isConntrolledByKI
                    KISystem.executeTurn(entity)
            else
                entity.resetActionPoints()
                board.getInitiative().next()
        else
            board.getInitiative().next()

    private static function dealDamageContinue(SpecificDamageInstance specificInstance, SequenzListener next)
        destroy specificInstance
        next.continue()

    static function dealDamage(BoardEntity source, DamageInstance instance, BoardStack target, SequenzListener next)
        let specificInstance = instance.getSpecific(source, target)
        if target.stats.getAmount() <= 0
            dealDamageContinue(specificInstance, next)
            return
        let coord = target.getCell().getCoord()
        
        standardTextTag(coord, Tooltip.coloredSpecificDamageInstance(specificInstance))
        target.stats.addAmount(-specificInstance.amount)
        
        if target.stats.getAmount() == 0
            if specificInstance.damageInstance.isTriggered
                destroy specificInstance
                killStack(target, next)
            else
                onDamageTaken(source, target, specificInstance) ->
                    onDamageDealt(source, target, specificInstance) ->
                        destroy specificInstance
                        killStack(target, next)
        else
            target.stats.setHp(specificInstance.remainingHp)
            if specificInstance.amount > 0
                UIController.triggerOnStackAmountChange(target)

            if specificInstance.damageInstance.isTriggered
                dealDamageContinue(specificInstance, next)
            else
                onDamageTaken(source, target, specificInstance) ->
                    onDamageDealt(source, target, specificInstance) ->
                        dealDamageContinue(specificInstance, next)

    
    /** triggers **/

    static function onDamageDealt(BoardEntity source, BoardStack target, SpecificDamageInstance specificInstance, SequenzListener next)
        if source.getType() == EntityType.STACK
            let stackSource = source.toStack()
            stackSource.getTriggers().triggerOnDamageDealt(source, target, specificInstance) ->
                next.continue()
        else
            next.continue()
        
    static function onDamageTaken(BoardEntity source, BoardStack target, SpecificDamageInstance specificInstance, SequenzListener next)
        target.getTriggers().triggerOnDamageTaken(source, target, specificInstance) ->
            next.continue()

    static function onAttackEnd(BoardStack attacker, BoardStack defender, SequenzListener next)
        nullTimer() ->
            defender.getTriggers().triggerOnAttacked(attacker, defender) ->
                next.continue()

    static function onTurnEnd(BoardEntity entity, boolean isWaiting, SequenzListener next)
        UIController.onTurnEnd(entity)
        
        if isWaiting == false and entity.isAlive()
            let actionItr = entity.getActions().iterator()
            while actionItr.hasNext()
                let action = actionItr.next()
                action.tickCooldown()
            destroy actionItr

            entity.getTriggers().triggerOnTurnEnd() ->
                next.continue()
        else
            next.continue()

    private static function turnStartContinue(BoardEntity entity)
        entity.resetCurrentSelectedAction()
        UIController.onTurnStart(entity)

        if entity.getPlayer().isConntrolledByKI
            KISystem.executeTurn(entity)
            
        
    private static function getWonnedSide(Board board) returns int
        var sideWon = -2
        let list = board.getAllStacks()
        let itr = list.iterator()
        while itr.hasNext() and sideWon != -1
            let stack = itr.next()
            let side = board.getPlayerIndex(stack.getPlayer())
            if sideWon == -2
                sideWon = side
            else if sideWon != side
                sideWon = -1

        destroy itr
        destroy list
        return sideWon

    static function onTurnStart(BoardEntity entity, boolean wasWaiting)
        nullTimer() ->
            let board = entity.getBoard()
            let side = getWonnedSide(board)
            if side == -1
                if wasWaiting
                    turnStartContinue(entity)
                else
                    entity.getTriggers().triggerOnTurnStart() ->
                        if entity.isAlive() and entity.canStillAct()
                            turnStartContinue(entity)
                        else
                            board.getInitiative().next()
            else
                MainController.endFight(board, side)
                    

    private static function onCellLeaveForAllStacks(LLIterator<BoardStack> stackItr, BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        if stackItr.hasNext()
            let current = stackItr.next()
            current.getTriggers().triggerOnAnyCellLeave(stack, fromCell, toCell) -> 
                onCellLeaveForAllStacks(stackItr, stack, fromCell, toCell, next)
        else
            next.continue()
                

    static function onCellLeave(BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        let board = stack.getBoard()
        let copy = board.getAllStacks()
        let stackItr = copy.iterator()
        onCellLeaveForAllStacks(stackItr, stack, fromCell, toCell) () ->
            destroy stackItr
            destroy copy
            next.continue()

            
    private static function onCellEnterForAllStacks(LLIterator<BoardStack> stackItr, BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        if stackItr.hasNext()
            let current = stackItr.next()
            current.getTriggers().triggerOnAnyCellEnter(stack, fromCell, toCell) -> 
                onCellEnterForAllStacks(stackItr, stack, fromCell, toCell, next)
        else
            next.continue()
                

    static function onCellEnter(BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        let board = stack.getBoard()
        let copy = board.getAllStacks()
        let stackItr = copy.iterator()
        onCellEnterForAllStacks(stackItr, stack, fromCell, toCell) () ->
            destroy stackItr
            destroy copy
            next.continue()