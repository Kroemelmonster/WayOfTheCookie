package BoardController

import ClosureTimers

import KISystem
import BuffController

import initlater BoardStack
import initlater Cell
import initlater UIController
import initlater Board
import initlater DamageResult
import initlater StandardTextTags
import initlater Action
import initlater OrderSystem
import initlater PassiveAction
import LinkedList
import BoardTrigger

constant TEXTTAG_COLOR_DAMAGE = colorA(246, 255, 120, 199)
constant TEXTTAG_COLOR_KILLS = colorA(255, 120, 120, 200)

public class BoardController
    /** Use this to summon / create a Stack mid Fight */
    static function placeStackOnBoard(BoardStack stack, Cell cell)
        let board = cell.getBoard()
        nullTimer() ->  
            board.placeStack(stack, cell, true)
            UIController.triggerOnStackCreationOrDeathChange(board)

    static function killStack(BoardStack stack, SequenzListener next)
        let board = stack.getCell().getBoard()
        nullTimer() ->  
            BuffController.removeAllBuffs(stack)
            stack.kill()
            UIController.triggerOnStackCreationOrDeathChange(board)
            next.continue()

    static function spendActionPoints(BoardStack stack, integer actionPoints, boolean isAllowedToContinue)
        stack.stats.setActionPoints(stack.stats.getRemainingActionPoints() - actionPoints)
        if isAllowedToContinue and stack.canStillAct()
            UIController.triggerOnActionPointChange(stack)
        else
            stack.stats.resetActionPopints()
            stack.stats.resetCounterAttacks()
            stack.getPlayer().playingBoard.getInitiative().next()

    static function finishAction(BoardStack stack)
        if stack.isAlive()
            spendActionPoints(stack, stack.stats.getRemainingActionPoints(), false)
        else
            stack.getPlayer().playingBoard.getInitiative().next()

    static function dealDamage(BoardStack _attacker, DamageResult data, BoardStack defender, SequenzListener next)
        let coord = defender.getCell().getCoord()

        standardTextTag(coord, data.damage.toString())
            ..setColor(TEXTTAG_COLOR_DAMAGE)
            ..setAge(1.0)
        if data.amount > 0
            standardTextTag(coord, data.amount.toString())
                ..setColor(TEXTTAG_COLOR_KILLS)
        
        defender.stats.addAmount(-data.amount)
        if defender.stats.getAmount() == 0
            killStack(defender, next)
        else
            defender.stats.setHp(data.remainingHP)
            if data.amount > 0
                UIController.triggerOnStackAmountChange(defender)
            next.continue()

        destroy data

    
    // passives
    private static function endTurn(BoardStack stack, Board board)
        finishAction(stack)
        OrderSystem.endOrder(board)
        
    private static function trigerAfterAttackNext(LLIterator<PassiveAction> itr, Board board, BoardStack attacker, BoardStack defender)
        if itr.hasNext() == false
            destroy itr
            endTurn(attacker, board)
            return
        let passive = itr.next()
        // what if defender or attacker dies ?? TODO
        if passive.triggerAfterAttackCheck(attacker)
            passive.triggerAfterAttack(attacker) -> 
                trigerAfterAttackNext(itr, board, attacker, defender)
        else
            destroy itr
            endTurn(attacker, board)

    private static function triggerAfterAttack(BoardStack attacker, BoardStack defender)
        let itr = defender.passiveActionIterator()
        let board = attacker.getBoard()
        trigerAfterAttackNext(itr, board, attacker, defender)

    static function onAttackEnd(BoardStack attacker, BoardStack defender)
        nullTimer() ->
            if defender.isAlive()
                triggerAfterAttack(attacker, defender)
            else
                endTurn(attacker, attacker.getBoard())

    static function onTurnEnd(BoardStack stack, boolean wasWaiting, SequenzListener next)
        UIController.onTurnEnd(stack)
        
        if wasWaiting == false and stack.isAlive()
            stack.forEachAction() (Action action) ->
                action.tickCooldown()
            stack.getTriggers().triggerOnTurnEnd() ->
                next.continue()
        else
            next.continue()



    private static function turnStartContinue(BoardStack stack)
        stack.setHighlight(true)
        stack.resetCurrentSelectedAction()
        UIController.onTurnStart(stack)

        if stack.getPlayer().isConntrolledByKI
            KISystem.executeTurn(stack)
            

    static function onTurnStart(BoardStack stack, boolean wasWaiting)
        nullTimer() ->
            if wasWaiting
                turnStartContinue(stack)
            else
                let board = stack.getBoard()
                stack.getTriggers().triggerOnTurnStart() ->
                    if stack.isAlive() and stack.canStillAct()
                        turnStartContinue(stack)
                    else
                        Log.trace("lOL YOU CANT DO SHIAT")
                        board.getInitiative().next()
                    

    static function onCellLeaveForAllStacks(LLIterator<BoardStack> stackItr, BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        if stackItr.hasNext()
            let current = stackItr.next()
            current.getTriggers().triggerOnAnyCellLeave(stack, fromCell, toCell) -> 
                onCellLeaveForAllStacks(stackItr, stack, fromCell, toCell, next)
        else
            destroy stackItr
            next.continue()
                

    static function onCellLeave(BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        let board = stack.getBoard()
        let stackItr = board.eachStackIterator()
        onCellLeaveForAllStacks(stackItr, stack, fromCell, toCell, next)
            
    static function onCellEnterForAllStacks(LLIterator<BoardStack> stackItr, BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        if stackItr.hasNext()
            let current = stackItr.next()
            current.getTriggers().triggerOnAnyCellEnter(stack, fromCell, toCell) -> 
                onCellEnterForAllStacks(stackItr, stack, fromCell, toCell, next)
        else
            destroy stackItr
            next.continue()
                

    static function onCellEnter(BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        let board = stack.getBoard()
        let stackItr = board.eachStackIterator()
        onCellEnterForAllStacks(stackItr, stack, fromCell, toCell, next)