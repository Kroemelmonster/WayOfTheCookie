package BoardController

import ClosureTimers
import LinkedList

import KISystem
import StatusController

import initlater BoardStack
import initlater Cell
import initlater Board
import initlater Damage
import initlater StandardTextTags
import initlater Action
import initlater OrderSystem
import initlater BoardTrigger
import initlater BoardEntity
import initlater Status
import initlater StatusType
import initlater ActionCost
import initlater StatusStunned
import initlater PathFinding

import initlater MainController
import initlater UIController
import initlater StackType
import initlater BoardForce
import CellObstacle
import BoardListenerOnCellMove

public class BoardController

    static function stunEntity(BoardEntity _source, BoardEntity target, int time, SequenzListener next)
        if target.isAlive() == false
            next.continue()
            return

        let board = target.getBoard()
        board.getInitiative().pushEntity(target, time)
        if target.getType() != EntityType.STACK
            next.continue()
            return
        let statusData = StatusData.create()
        ..setIntData(StatusStunned.DURATION, time)
        StatusController.apply(StatusStunned.TYPE, target, statusData) (status) ->
            next.continue()

    static function createSummon(BoardForce boardForce, StackType stackType, Cell cell,  int amount, SequenzListener next)
        nullTimer() -> 
            let board = boardForce.getBoard()
            let summon = boardForce.createSummon(stackType, amount)
            boardForce.placeStack(summon, cell, true)
            onCellEnter(summon, cell, cell) (cost) -> 
                UIController.triggerOnStackCreationOrDeathChange(board) -> 
                    next.continue()

    /** Use this to summon / create a Stack mid Fight */
    /*
    static function placeStackOnBoard(BoardStack stack, Cell cell, boolean isSummoned, SequenzListener next)
        let board = cell.getBoard()
        nullTimer() ->
            boardForce.placeStack(stack, cell, isSummoned)
            onCellEnter(stack, cell, cell) (cost) -> 
                UIController.triggerOnStackCreationOrDeathChange(board) -> 
                    next.continue()
                    */

    static function killStack(BoardStack stack, SequenzListener next)
        let board = stack.getBoard()
        nullTimer() ->  
            StatusController.removeAllBeforeDeath(stack)
            stack.kill()
            UIController.triggerOnStackCreationOrDeathChange(board) -> 
                next.continue()

    static function finishOrder(BoardEntity entity, ActionCost cost)
        finishOrder(entity, cost, 0)

    static function finishOrder(BoardEntity entity, ActionCost cost, int additonalAPCost)
        let board = entity.getBoard()
        OrderSystem.endOrder(board)
        if entity.isAlive()
            cost.pay(additonalAPCost)
            if entity.canStillAct()
                entity.resetCurrentSelectedAction()
                UIController.triggerOnActiveEntityActionPointChange(entity)
                if entity.getConntrollingPlayer().isConntrolledByKI()
                    KISystem.executeTurn(entity)
            else
                entity.resetAP()
                board.getInitiative().next()
        else
            board.getInitiative().next()
            
    static function dealDamage(BoardEntity source, DamageInstance originalDamageInstance, BoardEntity target, SequenzListener next)
        if target.getType() != EntityType.STACK
            next.continue()
            return
        let stackTarget = target.toStack()

        // cant deal damage to what is already dead
        if stackTarget.stats.getAmount() <= 0
            next.continue()
            return
        
        let instance = originalDamageInstance.copy()
        let specificInstance = instance.calculateDamageTo(source, stackTarget)
        calculateDamageBefore(source, specificInstance, stackTarget) ->
            specificInstance.applyResults()
            dealDamageInner(source, specificInstance, stackTarget) ->
                destroy instance
                destroy specificInstance
                if stackTarget.stats.getAmount() == 0
                    killStack(stackTarget, next)
                else
                    next.continue()

    private static function calculateDamageBefore(BoardEntity source, SpecificDamageInstance instance, BoardStack target, SequenzListener next)
        onBeforeDamageTaken(source, target, instance) ->
            onBeforeDamageDealt(source, target, instance) ->
                next.continue()

    private static function dealDamageInner(BoardEntity source, SpecificDamageInstance instance, BoardStack target, SequenzListener next)
        // apply the dmg
        standardTextTag(target.getCell().getCoord(), instance.toColoredText())

        // after damage trigers
        if instance.hasFlag(DamageFlags.TRIGGERED)
            next.continue()
        else
            onDamageTaken(source, target, instance) ->
                onDamageDealt(source, target, instance) ->
                    next.continue()
    /** triggers **/

    private static function onBeforeDamageDealt(BoardEntity source, BoardStack target, SpecificDamageInstance instance, SequenzListener next)
        source.getTriggers().triggerOnBeforeDamageDealt(source, target, instance) ->
            next.continue()

    private static function onBeforeDamageTaken(BoardEntity source, BoardStack target, SpecificDamageInstance instance, SequenzListener next)
        target.getTriggers().triggerOnBeforeDamageTaken(source, target, instance) ->
            next.continue()
            
    private static function onDamageTaken(BoardEntity source, BoardStack target, SpecificDamageInstance specificInstance, SequenzListener next)
        target.getTriggers().triggerOnDamageTaken(source, target, specificInstance) ->
            next.continue()

    private static function onDamageDealt(BoardEntity source, BoardStack target, SpecificDamageInstance specificInstance, SequenzListener next)
        source.getTriggers().triggerOnDamageDealt(source, target, specificInstance) ->
            next.continue()

    static function onAttackEnd(BoardStack attacker, BoardStack defender, SequenzListener next)
        nullTimer() ->
            defender.getTriggers().triggerOnAttacked(attacker, defender) ->
                next.continue()

    static function onTurnEnd(BoardEntity entity, boolean isWaiting, SequenzListener next)
        UIController.onTurnEnd(entity)
        
        if not isWaiting and entity.isAlive()
            entity.forEachAction() action ->
                action.tickCooldown()

            entity.getTriggers().triggerOnTurnEnd() ->
                next.continue()
        else
            next.continue()

    private static function turnStartContinue(BoardEntity entity)
        entity.resetCurrentSelectedAction()
        UIController.onTurnStart(entity)

        if entity.getConntrollingPlayer().isConntrolledByKI()
            KISystem.executeTurn(entity)
            
        
    private static function getWonnedSide(Board board) returns int
        var sideWon = -2
        // let list = board.getAllStacks()
        // let itr = list.iterator()
        // TODO
        return -1
        /*
        while itr.hasNext() and sideWon != -1
            let stack = itr.next()
            let side = board.getPlayerIndex(stack.getPlayer())
            if sideWon == -2
                sideWon = side
            else if sideWon != side
                sideWon = -1

        destroy itr
        destroy list
        return sideWon*/

    static function onTurnStart(BoardEntity entity, boolean wasWaiting)
        nullTimer() ->
            let board = entity.getBoard()
            let side = getWonnedSide(board)
            if side == -1
                if wasWaiting
                    turnStartContinue(entity)
                else
                    entity.getTriggers().triggerOnTurnStart() ->
                        if entity.isAlive() and entity.canStillAct()
                            turnStartContinue(entity)
                        else
                            board.getInitiative().next()
            else
                MainController.endFight(board, side)

    static function triggerOnCellEnterForBoardPlacement(Board board, SequenzListener next)
        let copy = board.getACopyOfAllStacks()
        let stackItr = copy.iterator()
        onCellEnterForBoardPlacements(stackItr, 0) (exectutions) -> 
            destroy copy
            destroy stackItr
            next.continue()
    
    static function onCellLeave(BoardStack stack, Cell fromCell, Cell toCell, SequenzListenerData<BoardListenerOnCellMoveData> next)
        let board = stack.getBoard()
        let copy = board.getACopyOfAllStacks()
        let stackItr = copy.iterator()
        let data = BoardListenerOnCellMoveData.create(stack, fromCell, toCell, false)
        onCellLeaveForAllStacks(stackItr, data) ->
            destroy stackItr
            destroy copy
            let copyObs = fromCell.getACopyOfAllObstacles()
            let obsItr = copyObs.iterator()
            onCellLeaveForCell(obsItr, data) ->
                destroy obsItr
                destroy copyObs
                next.continue(data)
                destroy data

    static function onCellEnter(BoardStack stack, Cell fromCell, Cell toCell, SequenzListenerData<BoardListenerOnCellMoveData> next)
        let board = stack.getBoard()
        let copy = board.getACopyOfAllStacks()
        let stackItr = copy.iterator()
        let data = BoardListenerOnCellMoveData.create(stack, fromCell, toCell, true)
        onCellEnterForAllStacks(stackItr, data) ->
            destroy stackItr
            destroy copy

            let copyObs = toCell.getACopyOfAllObstacles()
            let obsItr = copyObs.iterator()
            onCellEnterForCell(obsItr, data) ->
                destroy obsItr
                destroy copyObs
                next.continue(data)
                destroy data

    /* -------------------------------------------------- */

    private static function onCellEnterForBoardPlacements(LLIterator<BoardStack> itr, int executions, SequenzListenerData<int> next)
        if itr.hasNext()
            let stack = itr.next()
            onCellEnter(stack, null, stack.getCell()) (data) ->
                let usesExections = data.getExecutions()
                var newExections = executions + usesExections
                if usesExections == 0 // it is only 0 if it actually got reset. it is -1 if no triggers at all were executed
                    newExections = 0
                if newExections >= 50
                    newExections = 0
                    nullTimer() ->
                        onCellEnterForBoardPlacements(itr, newExections, next)
                else
                    onCellEnterForBoardPlacements(itr, newExections, next)
        else
            next.continue(executions)

    private static function onCellLeaveForAllStacks(LLIterator<BoardStack> itr, BoardListenerOnCellMoveData data, SequenzListener next)
        if itr.hasNext()
            itr.next().listeners().triggerOnAnyCellLeave(data) -> 
                onCellLeaveForAllStacks(itr, data, next)
        else
            next.continue()

    private static function onCellLeaveForCell(LLIterator<CellObstacle> itr,  BoardListenerOnCellMoveData data, SequenzListener next)
        if itr.hasNext()
            itr.next().triggerOnAnyCellEnter(data) -> 
                onCellLeaveForCell(itr, data, next)
        else
            next.continue()
                
    private static function onCellEnterForAllStacks(LLIterator<BoardStack> stackItr, BoardListenerOnCellMoveData data, SequenzListener next)
        if stackItr.hasNext()
            stackItr.next().listeners().triggerOnAnyCellEnter(data) ->
                onCellEnterForAllStacks(stackItr, data, next)
        else
            next.continue()

    private static function onCellEnterForCell(LLIterator<CellObstacle> itr, BoardListenerOnCellMoveData data, SequenzListener next)
        if itr.hasNext()
            itr.next().triggerOnAnyCellEnter(data) ->
                onCellEnterForCell(itr, data, next)
        else
            next.continue()