package BoardController

import ClosureTimers
import LinkedList

import KISystem
import StatusController

import initlater BoardStack
import initlater Cell
import initlater Board
import initlater Damage
import initlater StandardTextTags
import initlater Action
import initlater OrderSystem
import initlater BoardTrigger
import initlater BoardEntity
import initlater Status
import initlater StatusType
import initlater ActionCost
import initlater StatusStunned
import initlater PathFinding

import initlater MainController
import initlater UIController

public class BoardController

    static function stunEntity(BoardEntity _source, BoardEntity target, int time, SequenzListener next)
        if target.isAlive() == false
            next.continue()
            return

        let board = target.getBoard()
        board.getInitiative().pushEntity(target, time)
        if target.getType() != EntityType.STACK
            next.continue()
            return
        StatusController.apply(StatusStunned.TYPE, target, StatusData.create(1)) (status) ->
            next.continue()

    /** Use this to summon / create a Stack mid Fight */
    static function placeStackOnBoard(BoardStack stack, Cell cell, boolean isSummoned, SequenzListener next)
        let board = cell.getBoard()
        nullTimer() ->  
            board.placeStack(stack, cell, isSummoned)
            onCellEnter(stack, cell, cell) (cost) -> 
                UIController.triggerOnStackCreationOrDeathChange(board) -> 
                    next.continue()

    static function killStack(BoardStack stack, SequenzListener next)
        let board = stack.getBoard()
        nullTimer() ->  
            StatusController.hideAll(stack)
            stack.kill()
            UIController.triggerOnStackCreationOrDeathChange(board) -> 
                next.continue()

    static function finishOrder(BoardEntity entity, ActionCost cost)
        finishOrder(entity, cost, 0)

    static function finishOrder(BoardEntity entity, ActionCost cost, int additonalAPCost)
        let board = entity.getBoard()
        OrderSystem.endOrder(board)
        if entity.isAlive()
            cost.pay(additonalAPCost)
            if entity.canStillAct()
                entity.resetCurrentSelectedAction()
                UIController.triggerOnActiveEntityActionPointChange(entity)
                if entity.getConntrollingPlayer().isConntrolledByKI()
                    KISystem.executeTurn(entity)
            else
                entity.resetAP()
                board.getInitiative().next()
        else
            board.getInitiative().next()
            
    static function dealDamage(BoardEntity source, DamageInstance originalDamageInstance, BoardEntity target, SequenzListener next)
        if target.getType() != EntityType.STACK
            next.continue()
            return
        let stackTarget = target.toStack()

        // cant deal damage to what is already dead
        if stackTarget.stats.getAmount() <= 0
            next.continue()
            return
        
        let instance = originalDamageInstance.copy()
        calculateDamageBefore(source, instance, stackTarget) ->
            let specificInstance = instance.dealDamageTo(source, stackTarget)
            dealDamageInner(source, specificInstance, stackTarget) ->
                destroy instance
                destroy specificInstance
                if stackTarget.stats.getAmount() == 0
                    killStack(stackTarget, next)
                else
                    next.continue()

    private static function calculateDamageBefore(BoardEntity source, DamageInstance instance, BoardStack target, SequenzListener next)
        onBeforeDamageTaken(source, target, instance) ->
            onBeforeDamageDealt(source, target, instance) ->
                next.continue()

    private static function dealDamageInner(BoardEntity source, SpecificDamageInstance instance, BoardStack target, SequenzListener next)
        // apply the dmg
        standardTextTag(target.getCell().getCoord(), instance.toColoredText())

        // after damage trigers
        if instance.getDamageData().hasFlag(DamageFlags.TRIGGERED)
            next.continue()
        else
            onDamageTaken(source, target, instance) ->
                onDamageDealt(source, target, instance) ->
                    next.continue()
    /** triggers **/

    private static function onBeforeDamageDealt(BoardEntity source, BoardStack target, DamageInstance instance, SequenzListener next)
        source.getTriggers().triggerOnBeforeDamageDealt(source, target, instance) ->
            next.continue()

    private static function onBeforeDamageTaken(BoardEntity source, BoardStack target, DamageInstance instance, SequenzListener next)
        target.getTriggers().triggerOnBeforeDamageTaken(source, target, instance) ->
            next.continue()
            
    private static function onDamageTaken(BoardEntity source, BoardStack target, SpecificDamageInstance specificInstance, SequenzListener next)
        target.getTriggers().triggerOnDamageTaken(source, target, specificInstance) ->
            next.continue()

    private static function onDamageDealt(BoardEntity source, BoardStack target, SpecificDamageInstance specificInstance, SequenzListener next)
        source.getTriggers().triggerOnDamageDealt(source, target, specificInstance) ->
            next.continue()

    static function onAttackEnd(BoardStack attacker, BoardStack defender, SequenzListener next)
        nullTimer() ->
            defender.getTriggers().triggerOnAttacked(attacker, defender) ->
                next.continue()

    static function onTurnEnd(BoardEntity entity, boolean isWaiting, SequenzListener next)
        UIController.onTurnEnd(entity)
        
        if not isWaiting and entity.isAlive()
            entity.forEachAction() action ->
                action.tickCooldown()

            entity.getTriggers().triggerOnTurnEnd() ->
                next.continue()
        else
            next.continue()

    private static function turnStartContinue(BoardEntity entity)
        entity.resetCurrentSelectedAction()
        UIController.onTurnStart(entity)

        if entity.getConntrollingPlayer().isConntrolledByKI()
            KISystem.executeTurn(entity)
            
        
    private static function getWonnedSide(Board board) returns int
        var sideWon = -2
        let list = board.getAllStacks()
        let itr = list.iterator()
        while itr.hasNext() and sideWon != -1
            let stack = itr.next()
            let side = board.getPlayerIndex(stack.getPlayer())
            if sideWon == -2
                sideWon = side
            else if sideWon != side
                sideWon = -1

        destroy itr
        destroy list
        return sideWon

    static function onTurnStart(BoardEntity entity, boolean wasWaiting)
        nullTimer() ->
            let board = entity.getBoard()
            let side = getWonnedSide(board)
            if side == -1
                if wasWaiting
                    turnStartContinue(entity)
                else
                    entity.getTriggers().triggerOnTurnStart() ->
                        if entity.isAlive() and entity.canStillAct()
                            turnStartContinue(entity)
                        else
                            board.getInitiative().next()
            else
                MainController.endFight(board, side)
                    
    /** the sequenz has the cost for leaving the cell **/
    static function onCellLeave(BoardStack stack, Cell fromCell, Cell toCell, SequenzListenerData<int> next)
        let board = stack.getBoard()
        let copy = board.getAllStacks()
        let stackItr = copy.iterator()
        let initlatCost = PathFinding.getCellMoveOutCost(fromCell)
        onCellLeaveForAllStacks(stackItr, stack, fromCell, toCell, initlatCost) (newCost) ->
            destroy stackItr
            destroy copy
            next.continue(newCost)

    /** the sequenz has the cost for entering the cell **/
    static function onCellEnter(BoardStack stack, Cell fromCell, Cell toCell, SequenzListenerData<int> next)
        let board = stack.getBoard()
        let copy = board.getAllStacks()
        let stackItr = copy.iterator()
        let initlatCost = PathFinding.getCellMoveIntoCost(toCell)
        onCellEnterForAllStacks(stackItr, stack, fromCell, toCell, initlatCost) (newCost) ->
            destroy stackItr
            destroy copy
            next.continue(newCost)

    /* -------------------------------------------------- */

    private static function onCellLeaveForAllStacks(LLIterator<BoardStack> stackItr, BoardStack stack, Cell fromCell, Cell toCell, int prevCostToMove, SequenzListenerData<int> next)
        if stackItr.hasNext()
            let current = stackItr.next()
            current.getTriggers().triggerOnAnyCellLeave(stack, fromCell, toCell, prevCostToMove) (newCost) ->
                onCellLeaveForAllStacks(stackItr, stack, fromCell, toCell, newCost, next)
        else
            next.continue(prevCostToMove)
                
    private static function onCellEnterForAllStacks(LLIterator<BoardStack> stackItr, BoardStack stack, Cell fromCell, Cell toCell, int prevCostToMove, SequenzListenerData<int> next)
        if stackItr.hasNext()
            let current = stackItr.next()
            current.getTriggers().triggerOnAnyCellEnter(stack, fromCell, toCell, prevCostToMove) (newCost) ->
                onCellEnterForAllStacks(stackItr, stack, fromCell, toCell, newCost, next)
        else
            next.continue(prevCostToMove)