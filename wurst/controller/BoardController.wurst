package BoardController

import ClosureTimers

import KISystem
import BuffController

import initlater BoardStack
import initlater Cell
import initlater UIController
import initlater Board
import initlater DamageResult
import initlater StandardTextTags
import initlater Action
import initlater OrderSystem
import LinkedList
import BoardTrigger
import UITooltip
import StackType

constant TEXTTAG_COLOR_KILLS = colorA(250, 57, 57, 199).toColorString()

public class BoardController
    /** Use this to summon / create a Stack mid Fight */
    static function placeStackOnBoard(BoardStack stack, Cell cell)
        let board = cell.getBoard()
        nullTimer() ->  
            board.placeStack(stack, cell, true)
            UIController.triggerOnStackCreationOrDeathChange(board)

    static function killStack(BoardStack stack, SequenzListener next)
        let board = stack.getBoard()
        nullTimer() ->  
            BuffController.hideAllBuffs(stack)
            stack.kill()
            UIController.triggerOnStackCreationOrDeathChange(board)
            next.continue()

    static function finishOrder(BoardStack stack, boolean isAllowedToContinue)
        let board = stack.getBoard()
        OrderSystem.endOrder(board)
        if stack.isAlive()
            if isAllowedToContinue and stack.canStillAct()
                stack.resetCurrentSelectedAction()
                UIController.triggerOnActionPointChange(stack)
            else
                stack.stats.resetActionPoints()
                board.getInitiative().next()
        else
            board.getInitiative().next()

    private static function dealDamageContinue(DamageResult result, SequenzListener next)
        destroy result
        next.continue()

    static function dealDamage(BoardStack source, DamageResult result, BoardStack target, SequenzListener next)
        if target.stats.getAmount() <= 0
            dealDamageContinue(result, next)
            return
        let coord = target.getCell().getCoord()
        
        standardTextTag(coord, Tooltip.coloredDamageResult(result))
            ..setAge(0.0)
        target.stats.addAmount(-result.amount)
        
        if target.stats.getAmount() == 0
            if result.baseDamage.isTriggered()
                destroy result
                killStack(target, next)
            else
                onDamageTaken(source, target, result) ->
                    destroy result
                    killStack(target, next)
        else
            target.stats.setHp(result.remainingHP)
            if result.amount > 0
                UIController.triggerOnStackAmountChange(target)

            if result.baseDamage.isTriggered()
                dealDamageContinue(result, next)
            else
                onDamageTaken(source, target, result) ->
                    dealDamageContinue(result, next)

    
    /** triggers **/

    static function onDamageTaken(BoardStack source, BoardStack target, DamageResult result, SequenzListener next)
        target.getTriggers().triggerOnDamageTaken(source, target, result) ->
            next.continue()

    static function onAttackEnd(BoardStack attacker, BoardStack defender, SequenzListener next)
        nullTimer() ->
            defender.getTriggers().triggerOnAttacked(attacker, defender) ->
                next.continue()

    static function onTurnEnd(BoardStack stack, boolean wasWaiting, SequenzListener next)
        UIController.onTurnEnd(stack)
        
        if wasWaiting == false and stack.isAlive()
            stack.forEachAction() (Action action) ->
                action.tickCooldown()
            stack.getTriggers().triggerOnTurnEnd() ->
                next.continue()
        else
            next.continue()

    private static function turnStartContinue(BoardStack stack)
        stack.setHighlight(true)
        stack.resetCurrentSelectedAction()
        UIController.onTurnStart(stack)

        if stack.getPlayer().isConntrolledByKI
            KISystem.executeTurn(stack)
            

    static function onTurnStart(BoardStack stack, boolean wasWaiting)
        nullTimer() ->
            if wasWaiting
                turnStartContinue(stack)
            else
                let board = stack.getBoard()
                stack.getTriggers().triggerOnTurnStart() ->
                    if stack.isAlive() and stack.canStillAct()
                        turnStartContinue(stack)
                    else
                        board.getInitiative().next()
                    

    static function onCellLeaveForAllStacks(LLIterator<BoardStack> stackItr, BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        if stackItr.hasNext()
            let current = stackItr.next()
            current.getTriggers().triggerOnAnyCellLeave(stack, fromCell, toCell) -> 
                onCellLeaveForAllStacks(stackItr, stack, fromCell, toCell, next)
        else
            next.continue()
                

    static function onCellLeave(BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        let board = stack.getBoard()
        let copy = board.getAllStacks()
        let stackItr = copy.iterator()
        onCellLeaveForAllStacks(stackItr, stack, fromCell, toCell) () ->
            destroy stackItr
            destroy copy
            next.continue()

            
    static function onCellEnterForAllStacks(LLIterator<BoardStack> stackItr, BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        if stackItr.hasNext()
            let current = stackItr.next()
            current.getTriggers().triggerOnAnyCellEnter(stack, fromCell, toCell) -> 
                onCellEnterForAllStacks(stackItr, stack, fromCell, toCell, next)
        else
            next.continue()
                

    static function onCellEnter(BoardStack stack, Cell fromCell, Cell toCell, SequenzListener next)
        let board = stack.getBoard()
        let copy = board.getAllStacks()
        let stackItr = copy.iterator()
        onCellEnterForAllStacks(stackItr, stack, fromCell, toCell) () ->
            destroy stackItr
            destroy copy
            next.continue()