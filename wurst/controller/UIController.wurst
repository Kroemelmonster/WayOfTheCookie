package UIController

import UIEntityWindow
import UIWorldConsole

import initlater Board
import initlater PlayerData
import initlater Cell
import initlater BoardStack
import initlater Action

import initlater UIInitiativeWindow
import initlater UIActionWindow
import initlater OrderSystem
import initlater InitiativeList
import initlater MouseContext
import initlater BoardEntity
import BoardTrigger
import ClosureTimers
import LinkedList

class UIController

    static function selectEntity(Player p, BoardEntity entity)
        UIActionWindow.update(p)
        p.stackWindowInfo.setBoardEntity(entity)
            
    static function triggerOnActionChange(Board board)
        let currentEntry = board.getInitiative().getCurrent().getBoardEntity()
        currentEntry.getCurrentAction().onAnyStackCellChange()
        let currentPlayer = currentEntry.getPlayer()

        board.draw(currentPlayer)
        UIActionWindow.update(currentPlayer)

    static function triggerOnStackCreationOrDeathChange(Board board, SequenzListener next)
        triggerOnAnyStackCellChange(board) -> 
            // TODO this should be hannelded in initiative List
            UIInitiativeWindow.refresh(board.getInitiative())
            next.continue()

    static function triggerOnMaxActionPointChange(BoardEntity entity, SequenzListener next)
        entity.resetActionPoints()
        triggerOnAnyStackCellChange(entity.getBoard(), next)
        
    static function triggerOnAnyStackCellChange(Board board, SequenzListener next)
        let allstacks = board.getAllStacks()
        let itr = allstacks.iterator()
        triggerOnAnyStackCellChangeInner(itr) -> 
            destroy itr
            destroy allstacks
            board.drawAll()
            next.continue()

    private static function triggerOnAnyStackCellChangeInner(LLIterator<BoardStack> itr, SequenzListener next)
        nullTimer() -> 
            if itr.hasNext()
                itr.next().getDefaultAction().onAnyStackCellChange()
                triggerOnAnyStackCellChangeInner(itr, next)
            else
                next.continue()

    static function triggerOnPlayerCellHighlight(Player p)
        if OrderSystem.canOrder(p)
            // currentSelectStack is also the current stack inintaitve
            p.currentSelectedEntity.getCurrentAction().recalculateHighlight(p)

        
        p.playingBoard.draw(p)

    static function triggerOnStackAmountChange(BoardStack stack)
        UIInitiativeWindow.refresh(stack.getPlayer().playingBoard.getInitiative())
    
    static function onTurnEnd(BoardEntity entity)
        entity.setHighlight(false)
        UIActionWindow.hide(entity.getPlayer())

    static function onTurnStart(BoardEntity entity)
        MouseContext.forcePlayerSelect(entity.getPlayer(), entity.getCell())
        entity.setHighlight(true)
        entity.getBoard().drawAll()

    static function triggerOnActiveEntityActionPointChange(BoardEntity entity)
        UIActionWindow.update(entity.getPlayer())
        entity.getDefaultAction().onAnyStackCellChange()
        entity.getBoard().drawAll()

    private static function switchToCombat(Player p)
        if p.dialogInfo.current != null
            p.dialogInfo.current.cancel(p)
        p.stackWindowInfo.clear()
        UIWorldConsole.setVisible(p, false)
        UIInitiativeWindow.setVisible(p, true)

    static function switchToCombat(Board b)
        switchToCombat(b.getPlayer(0))
        switchToCombat(b.getPlayer(1))
        
    static function switchToWorld(Player p)
        p.stackWindowInfo.clear()
        p.blzPlayer.setCameraPosition(p.hero.getCoord())
        UIWorldConsole.setVisible(p, true)
        UIInitiativeWindow.setVisible(p, false)
        UIActionWindow.hide(p)