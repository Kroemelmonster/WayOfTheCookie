package SlamAction

import Icons
import Abilities

import Action
import InstantAction

import OrderSystem
import BoardController
import UITooltip
import BuffController
import BuffType
import UIActionWindow
import KUtil
import LinkedList
import Stack

import initlater BoardStack
import StackType
import Scheduler
import DelayAnimation
import Buff
import CastAnimation
import BoardTrigger
import HashMap
import Cell
import ClosureTimers
import Damage

public class SlamAction extends InstantAction
    static constant string NAME = "Slam"
    static constant string ICON = Icons.bTNGolemThunderClap

    private static constant int COST = 0
    private static constant int COOLDOWN = 2
    private static constant int MAXRANGE = 1
    private static constant string KEY = "S"
    private static constant string EFFECT = Abilities.thunderclapCaster
    private static BuffType BUFF

    private static constant real DAZZED = 60.0
    private static constant DamagePreview damagePreview = createDamagePreview()
    
    @inline
    private static function createDamagePreview() returns DamagePreview
        return new DamagePreview(realRange(0, 0), SourceType.SPELL, DamageType.PHYISICAL)

    private static function calculateDamage(int amount)
        damagePreview.dmg = realRange(100.0 * amount, 150.0 * amount)

    static function createTooltip(boolean isDefault, int amount) returns Tooltip
        calculateDamage(amount)
        let tt = Tooltip.create(NAME)
        ..setCooldown(COOLDOWN)
        ..setCost(COST)
        ..addLine(Tooltip.stat("Target", "Self"))
        ..addLine(Tooltip.stat("Range", MAXRANGE))
        ..addLine(Tooltip.stat("Damage", damagePreview))
        ..addLine("")
        ..addLine("Slams the Ground around and dealing massive AoE Damage")
        ..addLine("This Slam is so powerfull that enemys get "+Tooltip.secondaryString(BUFF.getName())+ " and placed back in the initaive by "+Tooltip.primaryString(DAZZED.round().toString())+ " time units")

        if isDefault == false
            tt.addKey(KEY)
        return tt

    static function setup()
        BUFF = BuffTypeSet.DAZED

    construct(BoardStack stack)
        super(stack, ICON, NAME)
        
    override function canActivate() returns boolean
        return cooldown <= 0

    private function getTargets() returns LinkedList<BoardStack>
        let area = stack.getCell().getAllCellsInRange(intRange(0, MAXRANGE))
        let targets = new LinkedList<BoardStack>()
        for cell in area
            let possibleTarget = cell.getStack()
            if possibleTarget != null and stack.isEnemy(possibleTarget)
                targets.add(possibleTarget)
        destroy area
        return targets

    private function hit(LLIterator<BoardStack> itr, DamageInstance instance)
        if itr.hasNext()
            let target = itr.next()
            BoardController.dealDamage(stack, instance, target) -> 
                if target.isAlive()
                    let level = target.getStackType().level
                    if level < 4
                        BoardController.pushInitiative(target, DAZZED)
                    else if level == 4
                        BoardController.pushInitiative(target, DAZZED / 2)
                    else if level == 5
                        BoardController.pushInitiative(target, DAZZED / 3)
                    BuffController.addBuff(BUFF, target, new BuffData(1))
                hit(itr, instance)
        else
            destroy itr
            destroy instance
            DelayAnimation.create(stack.getBoard(), 0.5) -> // this is the backswing for casting
                cooldown = COOLDOWN + 1

                stack.stats.addActionPoints(-COST)
                BoardController.finishOrder(stack, true)

    override function activate()
        let targets = getTargets()

        CastAnimation.create(stack) () ->
            flashEffect(EFFECT, stack.getCell().getCoord())
            calculateDamage(stack.stats.amount)
            hit(targets.iterator(), damagePreview.getRandomInstance())
            

    override function onUIMouseEnter()
        createTooltip(false, stack.stats.amount).display(stack.getPlayer(), true)
        UIActionWindow.updateActionPoints(stack, COST)
            
    override function onUIMouseLeave()
        UITooltip.hide(stack.getPlayer())
        UIActionWindow.updateActionPoints(stack, 0)

    override function canBeActivatedByKey(string key) returns boolean
        return key == KEY
            
    override function executeForKI(SequenzListenerStatus listener)
        let defaultAction = stack.getDefaultAction()
        let pathing = defaultAction.getPathing()
        let weightCells = new HashMap<Cell, real>()
        var cost = COST
        if cost == 0
            cost = 1 // after you moved all points you cant even use a spell that cost nothing
        let possibleMovePoints = stack.stats.getMoveSpeed() - cost
        Cell bestCell = null
        var highestWeightSoFar = 0.0
        var highestRemainingActionPoints = 0
        // what if possibleMovePoints <= 0 ?? nutzlos
        let stackItr = stack.getBoard().getAllStacks().iterator()
        while stackItr.hasNext()
            let target = stackItr.next()
            if target.isEnemy(stack)
                let weight =  target.stats.getWeight()
                let itr = target.getCell().eachCellInRangeIterator(intRange(1, MAXRANGE))
                while itr.hasNext()
                    let cell = itr.next()
                    let currentCost = pathing.get(cell).cost
                    if currentCost <= possibleMovePoints
                        var newWeight = weight
                        if weightCells.has(cell)
                            newWeight += weightCells.get(cell)
                        weightCells.put(cell, newWeight)
                        let remaining = (possibleMovePoints - currentCost).floor()
                        if newWeight > highestWeightSoFar
                            highestWeightSoFar = newWeight
                            bestCell = cell
                            highestRemainingActionPoints = remaining
                        else if newWeight == highestWeightSoFar and remaining > highestRemainingActionPoints
                            bestCell = cell
                            highestRemainingActionPoints = remaining

                destroy itr

        destroy stackItr
        destroy weightCells
        nullTimer() ->
            if bestCell != null
                if bestCell == stack.getCell()
                    activate()
                else
                    let order = defaultAction.caclulatePath(bestCell, null)
                
                    defaultAction.sendTargetOrder(order)
                listener.continue(0)
            else
                listener.continue(1)

    ondestroy
        