package SlamAction

import Icons
import Abilities

import Action
import InstantAction

import OrderSystem
import BoardController
import UITooltip
import StatusController
import StatusType
import UIActionWindow
import KUtil
import LinkedList
import Stack

import initlater BoardStack
import StackType
import Scheduler
import DelayAnimation
import Status
import CastAnimation
import BoardTrigger
import HashMap
import Cell
import ClosureTimers
import Damage

public class SlamAction extends InstantAction
    static constant string NAME = "Slam"
    static constant string ICON = Icons.bTNGolemThunderClap

    private static constant int COST = 0
    private static constant int COOLDOWN = 2
    private static constant int MAXRANGE = 1
    private static constant string KEY = "S"
    private static constant string EFFECT = Abilities.thunderclapCaster
    private static StatusType STATUS

    private static constant int DAZZED_TIME = 400
    private static constant int DAZZED_TIME_LVL_4 = 300
    private static constant int DAZZED_TIME_LVL_5 = 200
    private static constant DamagePreview damagePreview = createDamagePreview()
    
    @inline
    private static function createDamagePreview() returns DamagePreview
        return new DamagePreview(realRange(0, 0), SourceType.SPELL, DamageType.PHYISICAL)

    private static function calculateDamage(int amount)
        damagePreview.dmg = realRange(100.0 * amount, 150.0 * amount)

    static function createTooltip(boolean isDefault, int amount) returns Tooltip
        calculateDamage(amount)
        let tt = Tooltip.create(NAME)
        ..setCooldown(COOLDOWN)
        ..setCost(COST)
        ..addLine(Tooltip.stat("Target", "Self"))
        ..addLine(Tooltip.stat("Range", MAXRANGE))
        ..addLine(Tooltip.stat("Damage", damagePreview))
        ..addLine("")
        ..addLine("Slams the Ground around and dealing massive AoE Damage")
        ..addLine("This Slam is so powerfull that enemys get "+Tooltip.secondaryString(STATUS.getName())+ " and placed back in the initaive by "+Tooltip.primaryString(DAZZED_TIME.toString())+ " "+Tooltip.secondaryString("timeunits"))

        if isDefault == false
            tt.addKey(KEY)
        return tt

    static function setup()
        STATUS = StatusTypeSet.DAZED

    construct(BoardStack stack)
        super(stack, ICON, NAME)
        
    override function canActivate() returns boolean
        return cooldown <= 0

    private function getTargets() returns LinkedList<BoardStack>
        let area = stack.getCell().getAllCellsInRange(intRange(0, MAXRANGE))
        let targets = new LinkedList<BoardStack>()
        for cell in area
            let possibleTarget = cell.getStack()
            if possibleTarget != null and stack.isEnemy(possibleTarget)
                targets.add(possibleTarget)
        destroy area
        return targets

    private function hit(LLIterator<BoardStack> itr, DamageInstance instance)
        if itr.hasNext()
            let target = itr.next()
            BoardController.dealDamage(stack, instance, target) -> 
                if target.isAlive()
                    let level = target.getStackType().level
                    if level < 4
                        BoardController.pushBoardStackInInitiative(target, DAZZED_TIME)
                    else if level == 4
                        BoardController.pushBoardStackInInitiative(target, DAZZED_TIME_LVL_4)
                    else if level == 5
                        BoardController.pushBoardStackInInitiative(target, DAZZED_TIME_LVL_5)
                    StatusController.add(STATUS, target, new StatusData(1))
                hit(itr, instance)
        else
            destroy itr
            destroy instance
            DelayAnimation.create(stack.getBoard(), 0.5) -> // this is the backswing for casting
                cooldown = COOLDOWN + 1

                stack.addActionPoints(-COST)
                BoardController.finishOrder(entity, true)

    override function activate()
        let targets = getTargets()

        CastAnimation.create(stack) () ->
            flashEffect(EFFECT, stack.getCell().getCoord())
            calculateDamage(stack.stats.amount)
            hit(targets.iterator(), damagePreview.getRandomInstance())
            

    override function onUIMouseEnter()
        createTooltip(false, stack.stats.amount).display(stack.getPlayer(), true)
        UIActionWindow.updateActionPoints(entity, COST)
            
    override function onUIMouseLeave()
        UITooltip.hide(stack.getPlayer())
        UIActionWindow.updateActionPoints(entity, 0)

    override function canBeActivatedByKey(string key) returns boolean
        return key == KEY
            
    override function executeForKI(SequenzListenerStatus listener)
        let defaultAction = stack.getDefaultAction()
        let pathing = defaultAction.getPathing()
        let weightCells = new HashMap<Cell, real>()
        var cost = COST
        if cost == 0
            cost = 1 // after you moved all points you cant even use a spell that cost nothing
        Cell bestCell = null
        var highestWeightSoFar = 0.0
        var highestRemainingActionPoints = 0
        let stackItr = stack.getBoard().getAllStacks().iterator()
        while stackItr.hasNext()
            let target = stackItr.next()
            if target.isEnemy(stack)
                let weight =  target.stats.getWeight()
                let itr = target.getCell().eachCellInRangeIterator(intRange(1, MAXRANGE))
                while itr.hasNext()
                    let cell = itr.next()
                    var remaining = stack.getRemainingActionPoints()
                    if cell != stack.getCell()
                        remaining = -1
                        let pCell = pathing.get(cell)
                        if pCell != null
                            remaining = pCell.getRemainingActionPoints(stack)
                    if remaining >= cost
                        var newWeight = weight
                        if weightCells.has(cell)
                            newWeight += weightCells.get(cell)
                        weightCells.put(cell, newWeight)
                        if newWeight > highestWeightSoFar
                            highestWeightSoFar = newWeight
                            bestCell = cell
                            highestRemainingActionPoints = remaining
                        else if newWeight == highestWeightSoFar and remaining > highestRemainingActionPoints
                            bestCell = cell
                            highestRemainingActionPoints = remaining

                destroy itr

        destroy stackItr
        destroy weightCells
        nullTimer() ->
            if bestCell != null
                if bestCell == stack.getCell()
                    activate()
                else
                    let order = defaultAction.caclulatePath(bestCell, null)
                
                    defaultAction.sendTargetOrder(order)
                listener.continue(0)
            else
                listener.continue(1)

    ondestroy
        