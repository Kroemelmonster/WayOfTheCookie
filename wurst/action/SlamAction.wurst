package SlamAction

import Icons
import Abilities

import Action
import InstantAction

import OrderSystem
import BoardController
import UITooltip
import StatusController
import StatusType
import UIActionWindow
import KUtil
import LinkedList
import Stack

import initlater BoardStack
import StackType
import Scheduler
import DelayAnimation
import Status
import CastAnimation
import BoardTrigger
import HashMap
import Cell
import ClosureTimers
import Damage
import Globals

public class SlamAction extends InstantAction
    static constant string NAME = "Slam"
    static constant string ICON = Icons.bTNGolemThunderClap

    private static constant int COST = 0
    private static constant int COOLDOWN = 2
    private static constant int MAXRANGE = 1
    private static constant string KEY = "S"
    private static constant string EFFECT = Abilities.thunderclapCaster

    private static constant int DAZZED_TIME = 200
    private static constant DamagePreview damagePreview = createDamagePreview()
    
    @inline
    private static function createDamagePreview() returns DamagePreview
        return new DamagePreview(realRange(0, 0), SourceType.SPELL, DamageType.PHYISICAL)

    private static function calculateDamage(int amount)
        damagePreview.dmg = realRange(100.0 * amount, 150.0 * amount)

    static function createTooltip(boolean isDefault, int amount) returns Tooltip
        calculateDamage(amount)
        let tt = Tooltip.create(NAME)
        ..setCooldown(COOLDOWN)
        ..setCost(COST)
        ..addLine(Tooltip.stat("Target", "Self"))
        ..addLine(Tooltip.stat("Range", MAXRANGE))
        ..addLine(Tooltip.stat("Damage", damagePreview))
        ..addLine("")
        ..addLine("Slams the Ground around and dealing massive AoE Damage")
        ..addLine("This Slam is so powerfull that enemys get "+Tooltip.secondaryString(StatusTypeSet.STUNNED.getName())+ " and placed back in the initaive by "+Tooltip.primaryString(DAZZED_TIME.toString())+ " "+Tooltip.secondaryString("timeunits"))

        if isDefault == false
            tt.addKey(KEY)
        return tt

    construct(BoardStack stack)
        super(stack, ICON, NAME)
        
    override function canActivate() returns boolean
        return cooldown <= 0

    private function getTargets() returns LinkedList<BoardStack>
        let area = stack.getCell().getAllCellsInRange(intRange(0, MAXRANGE))
        let targets = new LinkedList<BoardStack>()
        for cell in area
            let possibleTarget = cell.getStack()
            if possibleTarget != null and stack.isEnemy(possibleTarget)
                targets.add(possibleTarget)
        destroy area
        return targets

    private function finish(LLIterator<BoardStack> itr, DamageInstance instance)
        destroy itr
        destroy instance
        DelayAnimation.create(stack.getBoard(), 0.5) -> // this is the backswing for casting
            cooldown = COOLDOWN + 1

            stack.addActionPoints(-COST)
            BoardController.finishOrder(entity, true)

    private function hit(LLIterator<BoardStack> itr, DamageInstance instance)
        if itr.hasNext()
            let target = itr.next()
            BoardController.dealDamage(stack, instance, target) -> 
                BoardController.stunEntity(stack, target, DAZZED_TIME) -> 
                    hit(itr, instance)
        else
            finish(itr, instance)

    override function activate()
        let targets = getTargets()

        CastAnimation.create(stack) () ->
            flashEffect(EFFECT, stack.getCell().getCoord())
            calculateDamage(stack.stats.amount)
            hit(targets.iterator(), damagePreview.getRandomInstance())
            

    override function onUIMouseEnter()
        createTooltip(false, stack.stats.amount).display(stack.getPlayer(), true)
        UIActionWindow.updateActionPoints(entity, COST)
            
    override function onUIMouseLeave()
        UITooltip.hide(stack.getPlayer())
        UIActionWindow.updateActionPoints(entity, 0)

    override function canBeActivatedByKey(string key) returns boolean
        return key == KEY
            
    override function executeForKI(SequenzListenerStatus listener)
        let defaultAction = stack.getDefaultAction()
        let pathing = defaultAction.getPathing()
        let weightCells = new HashMap<Cell, real>()
        var cost = COST
        if cost == 0
            cost = 1 // after you moved all points you cant even use a spell that cost nothing
        Cell bestCell = null
        var highestWeightSoFar = 0.0
        var highestRemainingActionPoints = 0
        let stackItr = stack.getBoard().getAllStacks().iterator()
        while stackItr.hasNext()
            let target = stackItr.next()
            if target.isEnemy(stack)
                let weight =  target.stats.getWeight()
                let itr = target.getCell().eachCellInRangeIterator(intRange(1, MAXRANGE))
                while itr.hasNext()
                    let cell = itr.next()
                    var remaining = stack.getRemainingActionPoints()
                    if cell != stack.getCell()
                        remaining = -1
                        let pCell = pathing.get(cell)
                        if pCell != null
                            remaining = pCell.getRaminingMoveActionPoints(stack)
                    if remaining >= cost
                        var newWeight = weight
                        if weightCells.has(cell)
                            newWeight += weightCells.get(cell)
                        weightCells.put(cell, newWeight)
                        if newWeight > highestWeightSoFar
                            highestWeightSoFar = newWeight
                            bestCell = cell
                            highestRemainingActionPoints = remaining
                        else if newWeight == highestWeightSoFar and remaining > highestRemainingActionPoints
                            bestCell = cell
                            highestRemainingActionPoints = remaining

                destroy itr

        destroy stackItr
        destroy weightCells
        nullTimer() ->
            if bestCell != null
                if bestCell == stack.getCell()
                    activate()
                else
                    let order = defaultAction.caclulatePath(bestCell, null)
                
                    defaultAction.sendTargetOrder(order)
                listener.continue(0)
            else
                listener.continue(1)

    ondestroy
        