package WalkAndAttackAction

import LinkedList

import Action

import PathFinding
import UIController

import PlayerData
import AttackAnimation
import DamageResult
import DefaultAction
import UITooltip
import BoardController
import TargetList
import KUtil
import OrderSystem

import initlater Cell
import initlater BoardStack
import UIActionWindow
import MovePositionAnimation
import Scheduler
import DelayAnimation

public class WalkAndAttackAction extends DefaultAction
    private StackPathFinding walkableCells
    private LinkedList<Cell> path
    private boolean wasPathLimited
    private AttackResultPreview preview
    private BoardStack orderedEnemy

    construct(BoardStack stack)
        super(stack, "Attack")
        walkableCells = new StackPathFinding(stack, 1.0)
        path = new LinkedList<Cell>()
        preview = new AttackResultPreview(stack, true)
        targets = new TargetList(stack) (BoardStack possibleStack) -> 
            return getCellToAttackFromWithCheck(possibleStack)

    override function getPreviewResultForCell(Cell cell) returns CellResult
        if canAttackTargetThisTurn(cell.getStack())
            return CellResult.NEGATIVE
        else if cell != stack.getCell() and getRemainingActionPointsFromCell(cell, stack.stats.getMoveSpeed()) >= 0
            return CellResult.DEFAULT
        return CellResult.NONE

    override function getHighlightResultForCell(Player p, Cell cell) returns CellResult
        if wasPathLimited == false and path.has(cell)
            return CellResult.POSITIVE
        return CellResult.NONE

    override function recalculatePreview()
        walkableCells.recalculate(KI_MOVEPOINTS)
        targets.recalculate()

    override function recalculateHighlight(Player p)
        let cell = p.currentMousePosition.cell
        caclulatePath(cell, p.currentMousePosition.nearbyCell)
        if preview.isEmpty()
            UITooltip.hide(stack.getPlayer())
        else
            let tt = Tooltip.create(name)
            preview.addToTooltip(tt)
            tt.display(stack.getPlayer(), true)
        
        var showCost = 0
        if cell != null
            if canAttackTargetThisTurn(cell.getStack())
                showCost = 99
                UIActionWindow.updateActionPoints(stack, 99)
            else if cell != stack.getCell()
                let remaining = getRemainingActionPointsFromCell(cell, stack.stats.getMoveSpeed())
                if remaining >= 0
                    showCost = stack.stats.getMoveSpeed().floor() - remaining
            
        UIActionWindow.updateActionPoints(stack, showCost)

    private function sendAttackOrder()
        let board = stack.getBoard()
        preview.update(orderedEnemy)
        new AttackAnimation(stack, orderedEnemy) () ->
            let delayTime = Scheduler.getTimeIn(0.5) // this is the backswing
            BoardController.dealDamage(stack, preview.getOneResult(), orderedEnemy) ->
                new DelayAnimation(board, delayTime) ->
                    BoardController.onAttackEnd(stack, orderedEnemy)
            

    private function moveNextCell(int index)
        let nextCell = path.get(index)
        let currentCell = stack.getCell()
        var prevCost = 0
        if walkableCells.has(currentCell)
            prevCost = walkableCells.get(currentCell).cost.floor()
        let cost = walkableCells.get(nextCell).cost.floor()
        let board = currentCell.getBoard()
        Log.trace("start to next cell "+cost.toString())
        BoardController.onCellLeave(stack, currentCell, nextCell) ->
            Log.trace("after Leave "+Scheduler.getCurrentTime().toString())
            if stack.isAlive() == false
                Log.trace("he died so next ?")
                OrderSystem.endOrder(board)
                board.getInitiative().next()
            else if cost > stack.stats.getRemainingActionPoints()
                Log.trace("he does not have enought action points to continue "+stack.stats.getRemainingActionPoints().toString()+ " so remove the prev cost "+prevCost.toString())
                BoardController.spendActionPoints(stack, prevCost, true)
                UIController.triggerOnAnyStackCellChange(board)
                OrderSystem.endOrder(board)
            else
                new MovePositionAnimation(stack, nextCell.getCoord()) () ->
                    stack.replaceCell(nextCell)
                    BoardController.onCellEnter(stack, currentCell, nextCell) ->
                        Log.trace("after Enter "+Scheduler.getCurrentTime().toString())
                        if stack.isAlive() == false
                            Log.trace("he died after so next ?")
                            OrderSystem.endOrder(board)
                            board.getInitiative().next()
                        else if cost >= stack.stats.getRemainingActionPoints()
                            Log.trace("he does not have enought action points to continue "+stack.stats.getRemainingActionPoints().toString()+ " so remove the next cost "+cost.toString())
                            BoardController.spendActionPoints(stack, cost, true)
                            UIController.triggerOnAnyStackCellChange(board)
                            OrderSystem.endOrder(board)
                        else if (index + 1) < path.size()
                            Log.trace("alles roger next cell")
                            moveNextCell(index + 1)
                        else if orderedEnemy != null and cost < stack.stats.getRemainingActionPoints()
                            Log.trace("can actually still attack")
                            UIController.triggerOnAnyStackCellChange(board)
                            sendAttackOrder()
                        else
                            Log.trace("we are at our destination but can still move on")
                            BoardController.spendActionPoints(stack, cost, true)
                            UIController.triggerOnAnyStackCellChange(board)
                            OrderSystem.endOrder(board)

    override function sendTargetOrder(Cell cell) returns boolean
        if path.has(cell)
            orderedEnemy = null
            moveNextCell(0)
            return true
        else 
            orderedEnemy = cell.getStack()
            if canAttackTargetThisTurn(orderedEnemy)
                // do we need to walk there ?
                if path.isEmpty()
                    sendAttackOrder()
                else
                    moveNextCell(0)
                return true
        
        return false

    private function getRemainingActionPointsFromCell(Cell cell, real limitMovesPoint) returns int
        if cell == null
            return -1
        // you are there ??
        if cell == stack.getCell()
            return 999
        if walkableCells.has(cell)
            return (limitMovesPoint - walkableCells.get(cell).cost).floor()
        return -1

    private function getCellToAttackFromWithCheck(BoardStack target) returns Cell
        if stack.canAttack(target)
            return getCellToAttackFrom(target, null)
        return null

    private function getCellToAttackFrom(BoardStack target, Cell preferedCell) returns Cell
        // first check the preferedCell ( This is used when the curser is over the enemy but closest to an other Cell )
        if getRemainingActionPointsFromCell(preferedCell, 100.0) > 0
            return preferedCell
        
        // now go through every Cell that would be in range
        var currentHighestRemainingPoints = 0
        Cell currentBest = null
        
        let possibleCellsToAttackFrom = target.getCell().getAllCellsInRange(stack.stats.getAttackRange())
        let itr = possibleCellsToAttackFrom.iterator()
        while itr.hasNext()
            let possibleCellToAttackFrom = itr.next()
            let remainingPoints = getRemainingActionPointsFromCell(possibleCellToAttackFrom, 100.0)
            if remainingPoints > currentHighestRemainingPoints
                currentHighestRemainingPoints = remainingPoints
                currentBest = possibleCellToAttackFrom
        destroy itr
        destroy possibleCellsToAttackFrom
        return currentBest

    override function getTargets(boolean shouldBeAbleToAttackThisTurn) returns LinkedList<BoardStack>
        let list = new LinkedList<BoardStack>()
        let itr = targets.iterator()
        while itr.hasNext()
            let target = itr.next()
            if shouldBeAbleToAttackThisTurn == false or getRemainingActionPointsFromCell(target.getAttackFrom(), stack.stats.getMoveSpeed()) > 0
                list.add(target.getTarget())


        destroy itr
        return list
    
    private function canAttackTargetThisTurn(BoardStack enemy) returns boolean
        let target = targets.find(enemy)
        return target != null and getRemainingActionPointsFromCell(target.getAttackFrom(), stack.stats.getMoveSpeed()) > 0

    private function isInRange(Cell fromPosition, BoardStack otherStack) returns boolean
        if otherStack == null
            return false
        let attackRange = stack.stats.getAttackRange()
        let distance = otherStack.getCell().getDistanceTo(fromPosition)
        return distance >= attackRange.min and distance <= attackRange.max

    override function caclulatePath(Cell targetCell, Cell preferedCell) returns Cell
        path.clear()
        preview.reset()
        wasPathLimited = false

        
        if targetCell == null
            return null

        PathCell _destionationPath = null

        let targetStack = targetCell.getStack()
        let target = targets.find(targetStack)

        // he found something to Attack
        if target != null
            _destionationPath = walkableCells.get(target.getAttackFrom())
        else 
            _destionationPath = walkableCells.get(targetCell)
            
        if _destionationPath == null
            // you didnt need to walk, maybe you are already in range ?
            if target != null
                preview.calculate(targetStack, stack.getCell())
                return targetCell
            // somehow we cant walk there and we also cant attack while standing still
            return null

        let movePoints = stack.stats.getMoveSpeed()
        let iter = _destionationPath.iterator()
        var couldAttack = false

        while iter.hasNext()
            let pCell = iter.next()
            let cost = pCell.cost.floor()
            // he can walk AND attack there
            if cost <= movePoints
                
                path.addtoStart(pCell.cell)

                // he can also attack there
                if cost < movePoints and isInRange(pCell.cell, targetStack)
                    couldAttack = true

            else
                wasPathLimited = true

        destroy iter

        if couldAttack
            preview.calculate(targetStack, path.peek())
            return targetCell
        else
            let endResultTarget = path.peek()
            if endResultTarget != targetCell
                wasPathLimited = true

            // ansotnen kansch nur laufen
            return endResultTarget

    ondestroy
        if walkableCells != null
            destroy walkableCells
        if path != null
            destroy path
        if preview != null
            destroy preview
        