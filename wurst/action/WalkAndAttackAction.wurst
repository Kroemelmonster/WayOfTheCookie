package WalkAndAttackAction

import LinkedList

import Action

import PathFinding
import UIController

import PlayerData
import AttackAnimation
import DamageResult
import DefaultAction
import UITooltip
import BoardController
import TargetList
import KUtil
import OrderSystem

import initlater Cell
import initlater BoardStack
import initlater Board
import UIActionWindow
import MovePositionAnimation
import Scheduler
import DelayAnimation
import BoardTrigger

function subActionMoveEnd(Board board, SequenzListenerStatus next, int status)
    UIController.triggerOnAnyStackCellChange(board)
    next.continue(status)

function subActionMoveInner(StackPathFinding walkableCells, LinkedList<Cell> path, int index, BoardStack stack, SequenzListenerStatus next)
    let nextCell = path.get(index)
    let currentCell = stack.getCell()
    var prevCost = 0
    if walkableCells.has(currentCell)
        prevCost = walkableCells.get(currentCell).cost.floor()
    let cost = walkableCells.get(nextCell).cost.floor()
    let board = currentCell.getBoard()
    BoardController.onCellLeave(stack, currentCell, nextCell) ->
        if stack.isAlive() == false
            subActionMoveEnd(board, next, 1)
        else if cost > stack.stats.getRemainingActionPoints()
            stack.stats.addActionPoints(-prevCost)
            subActionMoveEnd(board, next, 0)
        else
            new MovePositionAnimation(stack, nextCell.getCoord()) () ->
                stack.replaceCell(nextCell)
                BoardController.onCellEnter(stack, currentCell, nextCell) ->
                    if stack.isAlive() == false
                        subActionMoveEnd(board, next, 1)
                    else if cost >= stack.stats.getRemainingActionPoints()
                        stack.stats.addActionPoints(-cost)
                        subActionMoveEnd(board, next, 0)
                    else if (index + 1) < path.size()
                        subActionMoveInner(walkableCells, path, index + 1,stack, next)
                    else
                        stack.stats.addActionPoints(-cost)
                        subActionMoveEnd(board, next, 0)

public function subActionMove(StackPathFinding walkableCells, LinkedList<Cell> path, BoardStack stack, SequenzListenerStatus next)
    subActionMoveInner(walkableCells, path, 0, stack, next)


function subActionAttackEnd(int cost, BoardStack attacker, SequenzListenerStatus next, int status)
    if cost > 0
        attacker.stats.addActionPoints(-cost)
    next.continue(status)

public function subActionAttack(int cost, BoardStack attacker, BoardStack defender, AttackResultPreview preview, boolean triggerOnAttack, SequenzListenerStatus next)
    let board = attacker.getBoard()
    if cost > 0 and attacker.stats.getRemainingActionPoints() < cost
        next.continue(2) // insufienct Cost
        return

    preview.update(defender)
    AttackAnimation.create(attacker, defender) () ->
        BoardController.dealDamage(attacker, preview.getOneResult(), defender) ->
            DelayAnimation.create(board, Scheduler.getTimeIn(0.5)) -> // this is the backswing
                if triggerOnAttack
                    BoardController.onAttackEnd(attacker, defender) ->
                        subActionAttackEnd(cost, attacker, next, 0)
                else
                    subActionAttackEnd(cost, attacker, next, 0)

public class WalkAndAttackAction extends DefaultAction
    private StackPathFinding walkableCells
    private LinkedList<Cell> path
    private boolean wasPathLimited
    private AttackResultPreview preview

    construct(BoardStack stack)
        super(stack, "Attack")
        walkableCells = new StackPathFinding(stack, 1.0)
        path = new LinkedList<Cell>()
        preview = new AttackResultPreview(stack, true)
        targets = new TargetList(stack) (BoardStack possibleStack) -> 
            return getCellToAttackFromWithCheck(possibleStack)

    override function getPreviewResultForCell(Cell cell) returns CellResult
        if canAttackTargetThisTurn(cell.getStack())
            return CellResult.NEGATIVE
        else if cell != stack.getCell() and getRemainingActionPointsFromCell(cell, stack.stats.getMoveSpeed()) >= 0
            return CellResult.DEFAULT
        return CellResult.NONE

    override function getHighlightResultForCell(Player p, Cell cell) returns CellResult
        if wasPathLimited == false and path.has(cell)
            return CellResult.POSITIVE
        return CellResult.NONE

    override function recalculatePreview()
        walkableCells.recalculate(KI_MOVEPOINTS)
        targets.recalculate()

    override function recalculateHighlight(Player p)
        let cell = p.currentMousePosition.cell
        caclulatePath(cell, p.currentMousePosition.nearbyCell)
        if preview.isEmpty()
            UITooltip.hide(stack.getPlayer())
        else
            let tt = Tooltip.create(name)
            preview.addToTooltip(tt)
            tt.display(stack.getPlayer(), true)
        
        var showCost = 0
        if cell != null
            if canAttackTargetThisTurn(cell.getStack())
                showCost = 99
                UIActionWindow.updateActionPoints(stack, 99)
            else if cell != stack.getCell()
                let remaining = getRemainingActionPointsFromCell(cell, stack.stats.getMoveSpeed())
                if remaining >= 0
                    showCost = stack.stats.getMoveSpeed().floor() - remaining
            
        UIActionWindow.updateActionPoints(stack, showCost)

    override function sendTargetOrder(Cell cell) returns boolean
        var orderIsBeeingExecuted = false
        if path.has(cell)
            orderIsBeeingExecuted = true
            subActionMove(walkableCells, path, stack) (status) ->
                BoardController.finishOrder(stack, true)
        else
            let enemy = cell.getStack()
            if canAttackTargetThisTurn(enemy)
                orderIsBeeingExecuted = true
                // do we need to walk there ?
                if path.isEmpty()
                    subActionAttack(1, stack, enemy, preview, true) (attackStatus) ->
                        BoardController.finishOrder(stack, false)
                else
                    subActionMove(walkableCells, path, stack) (status) ->
                        if status == 0
                            subActionAttack(1, stack, enemy, preview, true) (attackStatus) ->
                                BoardController.finishOrder(stack, false)
                        else
                            // welp here you COULD theoretically act again but that is only a bug in subActionMove --> so we dont care
                            // if you ordered to attack someone and somthing does not work your turn is donso
                            BoardController.finishOrder(stack, false)
        return orderIsBeeingExecuted

    private function getRemainingActionPointsFromCell(Cell cell, real limitMovesPoint) returns int
        if cell == null
            return -1
        // you are there ??
        if cell == stack.getCell()
            return 999
        if walkableCells.has(cell)
            return (limitMovesPoint - walkableCells.get(cell).cost).floor()
        return -1

    private function getCellToAttackFromWithCheck(BoardStack target) returns Cell
        if stack.canAttack(target)
            return getCellToAttackFrom(target, null)
        return null

    private function getCellToAttackFrom(BoardStack target, Cell preferedCell) returns Cell
        // first check the preferedCell ( This is used when the curser is over the enemy but closest to an other Cell )
        if getRemainingActionPointsFromCell(preferedCell, 100.0) > 0
            return preferedCell
        
        // now go through every Cell that would be in range
        var currentHighestRemainingPoints = 0
        Cell currentBest = null
        
        let possibleCellsItr = target.getCell().eachCellInRangeIterator(stack.stats.getAttackRange())
        while possibleCellsItr.hasNext()
            let possibleCellToAttackFrom = possibleCellsItr.next()
            let remainingPoints = getRemainingActionPointsFromCell(possibleCellToAttackFrom, 100.0)
            if remainingPoints > currentHighestRemainingPoints
                currentHighestRemainingPoints = remainingPoints
                currentBest = possibleCellToAttackFrom
        destroy possibleCellsItr
        return currentBest

    override function getTargets(boolean shouldBeAbleToAttackThisTurn) returns LinkedList<BoardStack>
        let list = new LinkedList<BoardStack>()
        let itr = targets.iterator()
        while itr.hasNext()
            let target = itr.next()
            if shouldBeAbleToAttackThisTurn == false or getRemainingActionPointsFromCell(target.getAttackFrom(), stack.stats.getMoveSpeed()) > 0
                list.add(target.getTarget())


        destroy itr
        return list
    
    private function canAttackTargetThisTurn(BoardStack enemy) returns boolean
        let target = targets.find(enemy)
        return target != null and getRemainingActionPointsFromCell(target.getAttackFrom(), stack.stats.getMoveSpeed()) > 0

    private function isInRange(Cell fromPosition, BoardStack otherStack) returns boolean
        if otherStack == null
            return false
        let attackRange = stack.stats.getAttackRange()
        let distance = otherStack.getCell().getDistanceTo(fromPosition)
        return distance >= attackRange.min and distance <= attackRange.max

    override function caclulatePath(Cell targetCell, Cell preferedCell) returns Cell
        path.clear()
        preview.reset()
        wasPathLimited = false

        
        if targetCell == null
            return null

        PathCell _destionationPath = null

        let targetStack = targetCell.getStack()
        let target = targets.find(targetStack)

        // he found something to Attack
        if target != null
            _destionationPath = walkableCells.get(target.getAttackFrom())
        else 
            _destionationPath = walkableCells.get(targetCell)
            
        if _destionationPath == null
            // you didnt need to walk, maybe you are already in range ?
            if target != null
                preview.calculate(targetStack, stack.getCell())
                return targetCell
            // somehow we cant walk there and we also cant attack while standing still
            return null

        let movePoints = stack.stats.getMoveSpeed()
        let iter = _destionationPath.iterator()
        var couldAttack = false

        while iter.hasNext()
            let pCell = iter.next()
            let cost = pCell.cost.floor()
            // he can walk AND attack there
            if cost <= movePoints
                
                path.addtoStart(pCell.cell)

                // he can also attack there
                if cost < movePoints and isInRange(pCell.cell, targetStack)
                    couldAttack = true

            else
                wasPathLimited = true

        destroy iter

        if couldAttack
            preview.calculate(targetStack, path.peek())
            return targetCell
        else
            let endResultTarget = path.peek()
            if endResultTarget != targetCell
                wasPathLimited = true

            // ansotnen kansch nur laufen
            return endResultTarget

    ondestroy
        if walkableCells != null
            destroy walkableCells
        if path != null
            destroy path
        if preview != null
            destroy preview
        