package ActionSummonSkeleton

import StackActionTargetCell

import Abilities
import PlayerData
import BoardController
import StackType
import UIMenuActionConsole
import AnimationWait
import AnimationCast
import StackTypesData
import Scheduler

init
    Initializer.register(InitializerNames.ACTIONS) -> 
        ActionSummonSkeleton.setup()

public class ActionSummonSkeleton extends StackActionTargetCell
    static StackActionType TYPE

    protected static function setup()
        TYPE = StackActionTargetCell.createType("Summon Skeleton", Icons.bTNRaiseDead, ActionCostPreset.create(1, true, 3))
        ..enableOption(ActionTypeOption.PRIMARY)
        TYPE.onCreate() (BoardStack stack, StackActionData data) ->
            return new ActionSummonSkeleton(stack, data)
        TYPE.onCreateTooltipLines() data -> 
            return createTooltipLines(data)

    private static constant TARGET_RANGE = intRange(1, 1)
    private static constant string EFFECT = Abilities.raiseSkeleton
    private static StackType SUMMONED_TYPE

    private static function getSummonLeadershipLeadershipAmount(int amount) returns intRange
        return intRange((SUMMONED_TYPE.leadership * amount * 0.8).ceil(),
                        (SUMMONED_TYPE.leadership * amount * 1.2).ceil())

    private static function createTooltipLines(int amount) returns LinkedList<string>
        let leadership = getSummonLeadershipLeadershipAmount(amount)
        return new LinkedList<string>
        ..add(KStringUtils.stat("Target", "Empty Cell"))
        ..add(KStringUtils.stat("Range", TARGET_RANGE))
        ..add("")
        ..add("Summons a Stack of "
        + KStringUtils.coloredString(KStringUtils.COLOR_SECONDARY, SUMMONED_TYPE.name)
        + " with a Leaderhip of "
        + KStringUtils.coloredRange(KStringUtils.COLOR_PRIMARY, leadership))

    private static function createTooltipLines(StackActionData _data) returns LinkedList<string>
        return createTooltipLines(1)
      
    private static function createTooltipLines(ActionSummonSkeleton action) returns LinkedList<string>
        return createTooltipLines(action.stack.stats.amount)
    
/* -------------------------------------------------------------------------- */

    private Cell highlightedCell

    private construct(BoardStack stack, StackActionData data)
        super(stack, TYPE, data)
        SUMMONED_TYPE = StackTypes.find("Lesser Skeleton")

    override function recalculateHighlightInner(Cell target)
        highlightedCell = target

    override function getHighlightRuneRuneForCell(Player p, Cell cell) returns CellHighlightRune
        if cell == highlightedCell
            return CellHighlightRune.CAST
        return CellHighlightRune.NONE

    protected override function canTarget(Cell potentialTarget) returns boolean
        return potentialTarget.getStack() == null

    protected override function canHit(BoardStack target) returns boolean
        return false

    protected override function getTargetRange() returns intRange
        return TARGET_RANGE

    protected override function getAreaCellIterator(Cell target) returns LinkedListIterator<Cell>
        return new SingleCellIterator(target)

    protected override function previewTarget(int prevUsedApForMove, Cell target)
        let tt = createBasicTooltip()
        ..addLines(createBasicTooltipLines())

        UITooltip.display(stack.getConntrollingPlayer(), tt)
        UIMenuActionConsole.updateActionPoints(entity, cost, prevUsedApForMove)
    
    protected override function executeOrder(boolean didMove, int prevUsedApForMove, Cell target) returns boolean
        AnimationCast.atCell(stack, target) () ->
            flashEffect(EFFECT, target.getCoord())
            let waitUntil = Scheduler.getTimeIn(0.5)
            BoardController.createSummon(stack.getForce(), SUMMONED_TYPE, target, caclualateSummonAmount().random()) ->
                AnimationWait.untill(target.getBoard(), waitUntil) ->
                    BoardController.finishOrder(entity, cost)

        return true

    private function caclualateSummonAmount() returns intRange
        let amount = stack.stats.getAmount()
        let leadershipAmount = getSummonLeadershipLeadershipAmount(stack.stats.amount)
        return intRange((leadershipAmount.min / SUMMONED_TYPE.leadership).ceil(), (leadershipAmount.max / SUMMONED_TYPE.leadership).ceil())
    
    override function createBasicTooltipLines() returns LinkedList<string>
        return createTooltipLines(this)
    
    ondestroy
        