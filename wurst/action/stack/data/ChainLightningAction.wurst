package ChainLightningAction

import LinkedList
import Icons
import Lightning
import Abilities
import AttachmentPoints

import PlayerData
import KUtil
import BoardController
import OrderSystem

import Action
import StackType

import initlater Cell
import initlater BoardStack
import initlater StackTypesDefinition
import UIMenuActionConsole
import Scheduler
import AnimationWait
import Damage
import AnimationCast
import BoardTrigger
import HashMap
import ClosureTimers
import Effect
import StackAction
import ActionCost
import KStringUtils
import Tooltip
import UITooltip
import DamageAndResistance
import BoardEntity
import ActionType

public class ChainLightningAction extends StackAction
    static ActionType TYPE
    static function setup()
        TYPE = StackAction.createType("Chain Lightning", Icons.bTNChainLightning)
        ..enableOption(ActionTypeOption.PRIMARY)
        TYPE.onCreate() entity -> 
            return new ChainLightningAction(entity)
        TYPE.onCreateTooltipLines() amount -> 
            return createTooltipLines(amount, true)

    private static constant ActionCostPreset BASE_COST = ActionCostPreset.create(1, true, 3)
    private static constant int MAXRANGE = 4
    private static constant int MAX_CHAINS = 3
    private static constant int CHAIN_RANGE = 3
    private static constant real CHAIN_REDUCTION = 0.90
    
    private static constant DamagePreview damagePreview = createDamagePreview()
    
    private static function createDamagePreview() returns DamagePreview
        return new DamagePreview(realRange(0, 0), SourceType.SPELL, DamageType.MAGIC)

    private static function createBaseTooltipLines(boolean addCost) returns LinkedList<string>
        if addCost
            return BASE_COST.createTooltipLines()
        return new LinkedList<string>

    private static function createTooltipLines(int amount, boolean addCost) returns LinkedList<string>
        return createBaseTooltipLines(addCost)
        ..add(KStringUtils.stat("Target", "Enemy"))
        ..add(KStringUtils.stat("Damage", calculateDamage(amount, 0).toColoredText()))
        ..add("")
        ..add("Lightning strikes from one target and chains up to "
         + KStringUtils.primaryString(MAX_CHAINS.toString()) + " times")
        ..add("Each time the damage is descreased by "
         + KStringUtils.primaryPercent(1 - CHAIN_REDUCTION))

    private static function calculateDamage(int amount, int chain) returns DamagePreview
        var multi = 1.0
        for i = 1 to chain
            multi *= CHAIN_REDUCTION
        multi *= amount
        damagePreview.dmg = realRange(42.0 * multi, 55.0 * multi)
        return damagePreview
    
    private LinkedList<Cell> area = new LinkedList<Cell>()

    construct(BoardEntity entity)
        super(entity, TYPE, BASE_COST)

    override function getHighlightResultForCell(Player p, Cell cell) returns CellResult
        if area.has(cell)
            return CellResult.NEGATIVE
        return CellResult.NONE

    override function recalculatePreview()
        recalculatePossibleTargets()

    override function recalculateHighlight(Player p)
        if area.has(p.currentMousePosition.cell)
            showPreview(p.currentMousePosition.cell)
        else
            hidePreview()

    private function finishOrder(LinkedList<BoardStack> prevTargets, DamageInstance baseDamage)
        destroy prevTargets
        destroy baseDamage
        BoardController.finishOrder(entity, cost)

    private function chainToNext(LinkedList<BoardStack> prevTargets, BoardStack prev, Cell prevCell, DamageInstance baseDamage, BoardStack target, int chains)
        let targetPos = target.getPos3Real()
        var lightningModel = LIGHTNING_CHAIN_LIGHTNING_SEECONDARY
        if chains == 0
            lightningModel = LIGHTNING_CHAIN_LIGHTNING_PRIMARY
        let bolt = addLightning(lightningModel, true, prev.getPos3Real(), targetPos)
        let e = addEffect(Abilities.boltImpact, targetPos)
        AnimationWait.time(stack.getBoard(), 0.3) ->
            bolt.destr()
            e.setPosition(-100000, -10000, 10000)
            e.destr()
            let targetCell = target.getCell()
            BoardController.dealDamage(stack, baseDamage, target) -> 
                if chains < MAX_CHAINS
                    prevTargets.add(target)
                    baseDamage.dmg *= CHAIN_REDUCTION

                    Cell _newTargetCell = null
                    if target.isOnBoard()
                        // why not just use targetCell ?? because the unit might be moved so the chain goes on from there :O
                        _newTargetCell = target.getCell()
                    else
                        _newTargetCell = targetCell
                    let _nextTarget = getNextTarget(prevTargets, _newTargetCell)
                    if _nextTarget == null
                        finishOrder(prevTargets, baseDamage)
                    else
                        chainToNext(prevTargets, target, _newTargetCell, baseDamage, _nextTarget, chains + 1)
                else
                    finishOrder(prevTargets, baseDamage)

    override function sendTargetOrder(Cell cell) returns boolean
        if area.has(cell)
            AnimationCast.atCell(stack, cell) () ->
                calculateDamage(stack.stats.amount, 0)
                let rolledBaseDamage = damagePreview.getRandomInstance()
                chainToNext(new LinkedList<BoardStack>(), stack, stack.getCell(), rolledBaseDamage, cell.getStack(), 0)
            return true
        
        return false

    private function getNextTarget(LinkedList<BoardStack> prevTargets, Cell fromCell) returns BoardStack
        BoardStack nextTarget = null
        let itr = fromCell.eachCellInRangeIterator(intRange(1, CHAIN_RANGE))
        while itr.hasNext() and nextTarget == null
            let cell = itr.next()
            let possibleTarget = cell.getStack()
            if possibleTarget != null and possibleTarget.isEnemy(stack) and prevTargets.has(possibleTarget) == false
                nextTarget = possibleTarget

        destroy itr
        return nextTarget

    private function recalculatePossibleTargets()
        area.clear()

        stack.getCell().forEachCellsInRange(intRange(1, MAXRANGE)) (Cell cell) ->
            let possibleTarget = cell.getStack()
            if possibleTarget != null and possibleTarget.isEnemy(stack)
                area.add(cell)

    @inline
    private function showPreview(Cell fromCell)
        let tt = createBasicTooltip()
        ..addLines(createTooltipLines(stack.stats.amount, false))
        if fromCell != null
            let list = new LinkedList<BoardStack>()
            list.add(fromCell.getStack())
            tt.addLine("")
            var i = 0
            while i < MAX_CHAINS
                i++
                let nextTarget = getNextTarget(list, list.peek().getCell())
                if nextTarget != null
                    list.add(nextTarget)
                else
                    i = 100

            var chain = 0
            for target in list
                calculateDamage(stack.stats.amount, chain)
                .extendTooltipWithSpecific(tt, stack, target)
                chain ++
            destroy list
            
        UITooltip.display(stack.getPlayer(), tt)
        UIMenuActionConsole.updateActionPoints(entity, cost)
                
    @inline
    private function hidePreview()
        UITooltip.hide(stack.getPlayer())
        UIMenuActionConsole.updateActionPoints(entity)

    override function onUIMouseEnter()
        showPreview(null)

    override function onUIMouseLeave()
        hidePreview()

    override function executeForKI(SequenzListenerStatus listener)
        let defaultAction = stack.getDefaultAction()
        let pathing = defaultAction.getPathing()
        let weightCells = new HashMap<Cell, real>()
        var apCost = cost.getAP()
        if apCost == 0
            apCost = 1 // after you moved all points you cant even use a spell that cost nothing
        Cell bestCell = null
        BoardStack bestTarget = null
        var highestWeightSoFar = 0.0
        var highestRemainingActionPoints = 0
        // what if possibleMovePoints <= 0 ?? nutzlos
        let stackItr = stack.getBoard().getAllStacks().iterator()
        while stackItr.hasNext()
            let target = stackItr.next()
            if target.isEnemy(stack)
                let weight =  target.stats.getWeight()
                let itr = target.getCell().eachCellInRangeIterator(intRange(1, MAXRANGE))
                while itr.hasNext()
                    let cell = itr.next()
                    var remaining = stack.getRemainingActionPoints()
                    if cell != stack.getCell()
                        remaining = -1
                        let pCell = pathing.get(cell)
                        if pCell != null
                            remaining = pCell.getRaminingMoveActionPoints(stack)
                    if remaining >= apCost
                        let newWeight = weight
                        weightCells.put(cell, newWeight)
                        if newWeight > highestWeightSoFar
                            highestWeightSoFar = newWeight
                            bestCell = cell
                            bestTarget = target
                            highestRemainingActionPoints = remaining
                        else if newWeight == highestWeightSoFar and remaining > highestRemainingActionPoints
                            bestCell = cell
                            bestTarget = target
                            highestRemainingActionPoints = remaining

                destroy itr

        destroy stackItr
        destroy weightCells
        nullTimer() ->
            if bestCell != null
                if bestCell == stack.getCell()
                    activate()
                    nullTimer() ->
                        sendTargetOrder(bestTarget.getCell())
                else
                    let order = defaultAction.caclulatePath(bestCell, null)
                
                    defaultAction.sendTargetOrder(order)
                listener.continue(0)
            else
                listener.continue(1)

    ondestroy
        if area != null
            destroy area
        