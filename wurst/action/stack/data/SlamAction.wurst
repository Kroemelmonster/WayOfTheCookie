package SlamAction

import Icons
import Abilities

import Action
import InstantStackAction

import BoardController
import StatusType
import UIMenuActionConsole
import KUtil
import LinkedList
import Stack

import initlater BoardStack
import StackType
import Scheduler
import DelayAnimation
import Status
import CastAnimation
import BoardTrigger
import HashMap
import Cell
import ClosureTimers
import Damage
import Globals
import ActionCost
import KStringUtils
import Tooltip
import UITooltip
import DamageAndResistance
import ActionType
import BoardEntity

public class SlamAction extends InstantStackAction
    static ActionType TYPE
    static function setup()
        TYPE = InstantStackAction.createType("Slam", Icons.bTNGolemThunderClap)
        ..enableOption(ActionTypeOption.PRIMARY)
        TYPE.onCreate() entity -> 
            return new SlamAction(entity)
        TYPE.onCreateTooltipLines() amount -> 
            return createTooltipLines(amount, true)

    private static constant ActionCostPreset BASE_COST = ActionCostPreset.create(1, false, 2)
    private static constant int MAXRANGE = 1
    private static constant string EFFECT = Abilities.thunderclapCaster

    private static constant int DAZZED_TIME = 200
    private static constant DamagePreview damagePreview = createDamagePreview()
    
    private static function createDamagePreview() returns DamagePreview
        return new DamagePreview(realRange(0, 0), SourceType.SPELL, DamageType.PHYISICAL)

    private static function createBaseTooltipLines(boolean addCost) returns LinkedList<string>
        if addCost
            return BASE_COST.createTooltipLines()
        return new LinkedList<string>

    private static function createTooltipLines(int amount, boolean addCost) returns LinkedList<string>
        return createBaseTooltipLines(addCost)
        ..add(KStringUtils.stat("Target", "None"))
        ..add(KStringUtils.stat("Range", MAXRANGE))
        ..add(KStringUtils.stat("Damage", calculateDamage(amount).toColoredText()))
        ..add("")
        ..add("Slams the Ground around you, curshing your foes.")
        ..add("Stunning them for "
         + KStringUtils.primaryString(DAZZED_TIME.toString())
         + " " + KStringUtils.secondaryString("timeunits"))

    private static function calculateDamage(int amount) returns DamagePreview
        damagePreview.dmg = realRange(100.0 * amount, 150.0 * amount)
        return damagePreview

    construct(BoardEntity entity)
        super(entity, TYPE, BASE_COST)

    private function getTargets() returns LinkedList<BoardStack>
        let area = stack.getCell().getAllCellsInRange(intRange(0, MAXRANGE))
        let targets = new LinkedList<BoardStack>()
        for cell in area
            let possibleTarget = cell.getStack()
            if possibleTarget != null and stack.isEnemy(possibleTarget)
                targets.add(possibleTarget)
        destroy area
        return targets

    private function finish(LLIterator<BoardStack> itr, DamageInstance instance)
        destroy itr
        destroy instance
        DelayAnimation.create(stack.getBoard(), 0.5) -> // this is the backswing for casting
            BoardController.finishOrder(entity, cost)

    private function hit(LLIterator<BoardStack> itr, DamageInstance instance)
        if itr.hasNext()
            let target = itr.next()
            BoardController.dealDamage(stack, instance, target) -> 
                BoardController.stunEntity(stack, target, DAZZED_TIME) -> 
                    hit(itr, instance)
        else
            finish(itr, instance)

    override function activate()
        let targets = getTargets()

        CastAnimation.create(stack) () ->
            flashEffect(EFFECT, stack.getCell().getCoord())
            calculateDamage(stack.stats.amount)
            hit(targets.iterator(), damagePreview.getRandomInstance())

    override function onUIMouseEnter()
        let tt = createBasicTooltip()
        ..addLines(createTooltipLines(stack.stats.amount, false))
        UITooltip.display(stack.getPlayer(), tt)
        UIMenuActionConsole.updateActionPoints(entity, cost)
            
    override function onUIMouseLeave()
        UITooltip.hide(stack.getPlayer())
        UIMenuActionConsole.updateActionPoints(entity)
            
    override function executeForKI(SequenzListenerStatus listener)
        let defaultAction = stack.getDefaultAction()
        let pathing = defaultAction.getPathing()
        let weightCells = new HashMap<Cell, real>()
        var apCost = cost.getAP()
        if apCost == 0
            apCost = 1 // after you moved all points you cant even use a spell that cost nothing
        Cell bestCell = null
        var highestWeightSoFar = 0.0
        var highestRemainingActionPoints = 0
        let stackItr = stack.getBoard().getAllStacks().iterator()
        while stackItr.hasNext()
            let target = stackItr.next()
            if target.isEnemy(stack)
                let weight =  target.stats.getWeight()
                let itr = target.getCell().eachCellInRangeIterator(intRange(1, MAXRANGE))
                while itr.hasNext()
                    let cell = itr.next()
                    var remaining = stack.getRemainingActionPoints()
                    if cell != stack.getCell()
                        remaining = -1
                        let pCell = pathing.get(cell)
                        if pCell != null
                            remaining = pCell.getRaminingMoveActionPoints(stack)
                    if remaining >= apCost
                        var newWeight = weight
                        if weightCells.has(cell)
                            newWeight += weightCells.get(cell)
                        weightCells.put(cell, newWeight)
                        if newWeight > highestWeightSoFar
                            highestWeightSoFar = newWeight
                            bestCell = cell
                            highestRemainingActionPoints = remaining
                        else if newWeight == highestWeightSoFar and remaining > highestRemainingActionPoints
                            bestCell = cell
                            highestRemainingActionPoints = remaining

                destroy itr

        destroy stackItr
        destroy weightCells
        nullTimer() ->
            if bestCell != null
                if bestCell == stack.getCell()
                    activate()
                else
                    let order = defaultAction.caclulatePath(bestCell, null)
                
                    defaultAction.sendTargetOrder(order)
                listener.continue(0)
            else
                listener.continue(1)

    ondestroy
        