package WarcryAction


import Icons
import Abilities

import Action
import InstantAction

import BoardController
import UITooltip
import StatusController
import StatusType
import UIActionWindow
import KUtil
import LinkedList

import initlater BoardStack
import StackType
import DelayAnimation
import Status
import CastAnimation
import BoardTrigger
import HashMap
import Cell
import ClosureTimers

public class WarcryAction extends InstantAction
    static constant string NAME = "Warcry"
    static constant string ICON = Icons.bTNBattleRoar
    
    private static constant int COST = 0
    private static constant int COOLDOWN = 0
    private static constant int MAXRANGE = 3
    private static constant int BUFF_DURATION = 3
    private static constant string KEY = "Y"
    private static constant string EFFECT = Abilities.roarCaster
    private static StatusType BUFF
    private static Tooltip BASE_TOOLTIP

    static function setup()
        BUFF = StatusTypeSet.WARCRY
        BASE_TOOLTIP = Tooltip.create(NAME)
        ..setCost(COST)
        
        ..addLine(Tooltip.stat("Target", "Self"))
        ..addLine(Tooltip.stat("Range", MAXRANGE))
        ..addLine("")
        ..addLine("Gives every enemy unit in range the "+Tooltip.secondaryString(BUFF.getName())+ " Buff effect for "+Tooltip.primaryString(BUFF_DURATION.toString())+ " rounds")
        ..addLine("-----")
        ..addStatusType(BUFF, StatusData.create())

    private Tooltip tooltip
    construct(BoardStack stack)
        super(stack, ICON, NAME)
        charge = 1
        tooltip = Tooltip.copy(BASE_TOOLTIP)
        ..addKey(KEY)

    static function createTooltip(StackType _sType) returns Tooltip
        return Tooltip.copy(BASE_TOOLTIP)
        
    override function canActivate() returns boolean
        return charge > 0 and cooldown <= 0

    private function getTargets() returns LinkedList<BoardStack>
        let area = stack.getCell().getAllCellsInRange(intRange(0, MAXRANGE))
        let targets = new LinkedList<BoardStack>()
        for cell in area
            let possibleTarget = cell.getStack()
            if possibleTarget != null and stack.isEnemy(possibleTarget) == false
                targets.add(possibleTarget)
        destroy area
        return targets

    override function activate()
        let targets = getTargets()
        let board = stack.getBoard()

        CastAnimation.create(stack) () ->
            flashEffect(EFFECT, stack.getCell().getCoord())
            for target in targets
                StatusController.add(BUFF, target, StatusData.createDuration(BUFF_DURATION))
            destroy targets

            DelayAnimation.create(board, 0.5) -> // this is the backswing for casting
                charge --
                cooldown = COOLDOWN + 1

                stack.addActionPoints(-COST)
                BoardController.finishOrder(entity, true)
            

    override function onUIMouseEnter()
        tooltip.display(stack.getPlayer(), false)
        UIActionWindow.updateActionPoints(entity, COST)
            
    override function onUIMouseLeave()
        UITooltip.hide(stack.getPlayer())
        UIActionWindow.updateActionPoints(entity, 0)

    override function canBeActivatedByKey(string key) returns boolean
        return key == KEY
            
    override function executeForKI(SequenzListenerStatus listener)
        let defaultAction = stack.getDefaultAction()
        let pathing = defaultAction.getPathing()
        let weightCells = new HashMap<Cell, real>()
        var cost = COST
        if cost == 0
            cost = 1 // after you moved all points you cant even use a spell that cost nothing
        Cell bestCell = null
        var highestWeightSoFar = 0.0
        var highestRemainingActionPoints = 0
        // what if possibleMovePoints <= 0 ?? nutzlos
        let stackItr = stack.getBoard().getAllStacks().iterator()
        while stackItr.hasNext()
            let target = stackItr.next()
            if stack != target and target.isEnemy(stack) == false
                let itr = target.getCell().eachCellInRangeIterator(intRange(1, MAXRANGE))
                while itr.hasNext()
                    let cell = itr.next()
                    var remaining = stack.getRemainingActionPoints()
                    if cell != stack.getCell()
                        remaining = -1
                        let pCell = pathing.get(cell)
                        if pCell != null
                            remaining = pCell.getRaminingMoveActionPoints(stack)
                    if remaining >= cost
                        var newWeight = 100.0
                        if weightCells.has(cell)
                            newWeight += weightCells.get(cell)
                        weightCells.put(cell, newWeight)
                        if newWeight > highestWeightSoFar
                            highestWeightSoFar = newWeight
                            bestCell = cell
                            highestRemainingActionPoints = remaining
                        else if newWeight == highestWeightSoFar and remaining > highestRemainingActionPoints
                            bestCell = cell
                            highestRemainingActionPoints = remaining

                destroy itr

        destroy stackItr
        destroy weightCells
        nullTimer() ->
            if bestCell != null
                if bestCell == stack.getCell()
                    activate()
                else
                    let order = defaultAction.caclulatePath(bestCell, null)
                
                    defaultAction.sendTargetOrder(order)
                listener.continue(0)
            else
                listener.continue(1)

    ondestroy
        if tooltip != null
            destroy tooltip
        