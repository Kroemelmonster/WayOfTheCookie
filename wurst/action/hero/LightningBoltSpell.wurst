package LightningBoltSpell

import LinkedList
import Doodads

import PlayerData
import KUtil
import UITooltip
import BoardController

import Action
import StackType

import initlater Cell
import initlater BoardStack
import UIActionWindow
import DelayAnimation
import Damage
import CastAnimation
import BoardTrigger
import Spell
import BoardHero
import BoardEntity
import SkillTreeTempestarii
import SkillTree
import Globals
import StatusType
import StatusController
import Status
import UIController
import PurgedDebuff
import ActionCost

public class LightningBoltSpell extends Spell
    static SpellType TYPE
    static function setup()
        PURGE_DEBUFF = PurgedDebuff.TYPE
        TYPE = new SpellType("Lightning Bolt", "Icons\\BTNLightningBolt.blp")
        TYPE.onCreate() boardHero -> 
            return new LightningBoltSpell(boardHero)

    private static constant ActionCostPreset BASE_COST = ActionCostPreset.create(1, true, 0)
    private static constant int array[5] MANA_COST = [4, 5, 6, 7, 8]
    private static constant int array[5] DAMAGE = [60, 130, 210, 300, 500]
    private static constant DamagePreview damagePreview = DamagePreview.create(SourceType.SPELL, DamageType.MAGIC)
    static constant int array[3] STUN_DURATION = [100, 200, 400]
    static constant int array[3] PURGE_SLOW = [1, 2, 3]
    static StatusType PURGE_DEBUFF
    
    private static function calculateDamage(int power, int level)
        let multi = (1.0 + (power * DAMAGE_PER_SPELLPOWER / 100.0)) 
        damagePreview.dmg = realRange(DAMAGE[level] * 0.5 * multi, DAMAGE[level] * 2 * multi)

    @inline
    private static function createPurgeStatusData(int purgeLevel) returns StatusData
        return StatusData.createDurationI(2, PURGE_SLOW[purgeLevel])

    private static function adjustCost(ActionCostPreset cost, int level)
        cost.adjustBaseManaCost(MANA_COST[level])

    static function createTooltip(int level) returns Tooltip
        adjustCost(BASE_COST, level)
        return createTooltip(0, level, -1, -1, BASE_COST)

    private static function createTooltip(int power, int level, int stunLevel, int purgeLevel, ActionCostPreset cost) returns Tooltip
        calculateDamage(power, level)
        let tt = Tooltip.create(TYPE.getName())
        ..setCost(cost)
        ..addLine(Tooltip.stat("Target", "Enemy"))
        ..addLine(Tooltip.stat("Damage", damagePreview))
        ..addLine("")
        var str = "Lightning strikes"
        if stunLevel >= 0
            str += " and stuns for "+Tooltip.primaryString(STUN_DURATION[stunLevel].toString())+ " "+Tooltip.secondaryString("timeunits")
        if purgeLevel >= 0
            str += " and purges"
        str +=" one Enemy"
        tt.addLine(str)
        if purgeLevel >= 0
            tt.addLine("---")
            tt.addStatusType(PURGE_DEBUFF, createPurgeStatusData(purgeLevel))
        return tt
    
    /* -------------------------------------------------------------------------- */

    private LinkedList<Cell> area = new LinkedList<Cell>()
    private int stunLevel
    private int purgeLevel

    private construct(BoardHero hero)
        super(hero, TYPE, BASE_COST)
        let skillTree = hero.hero.getSkillTree(SkillTreeTempestarii.TYPE) castTo SkillTreeTempestarii
        setLevel(skillTree.lightningBoltLevel)
        adjustCost(cost, level)
        stunLevel = skillTree.lightningBoltStunLevel
        purgeLevel = skillTree.lightningBoltPurgeLevel

    override function getHighlightResultForCell(Player p, Cell cell) returns CellResult
        if area.has(cell)
            return CellResult.NEGATIVE
        return CellResult.NONE

    override function recalculatePreview()
        recalculatePossibleTargets()

    override function recalculateHighlight(Player p)
        if area.has(p.currentMousePosition.cell)
            showPreview(p.currentMousePosition.cell)
        else
            hidePreview()

    override function onUIMouseEnter()
        showPreview(null)

    override function onUIMouseLeave()
        hidePreview()

    override function sendTargetOrder(Cell cell) returns boolean
        // can not cast at something that is not targetable
        if area.has(cell) == false
            return false

        CastAnimation.create(hero, cell) () ->
            calculateDamage(hero.stats.getPower(), level)
            let rolledBaseDamage = damagePreview.getRandomInstance()
            let target = cell.getStack()
            let e = addEffect(Doodads.lightningbolt, target.getPos3Real())
            DelayAnimation.create(entity.getBoard(), 0.3) ->
                e.destr()
                BoardController.dealDamage(hero, rolledBaseDamage, target) -> 
                    destroy rolledBaseDamage
                    afterDamage(target)
        return true

    private function afterDamage(BoardStack target)
        if stunLevel < 0 and purgeLevel < 0
            finishOrder()
            return
        if target.isAlive() == false
            finishOrder()
            return

        if stunLevel >= 0
            BoardController.stunEntity(hero, target, STUN_DURATION[stunLevel]) -> 
                finishOrder()
        else if purgeLevel >= 0
            StatusController.add(PURGE_DEBUFF, target, createPurgeStatusData(purgeLevel))
            UIController.triggerOnMaxActionPointChange(target) -> 
                finishOrder()

    private function finishOrder()
        BoardController.finishOrder(entity, cost)

    private function recalculatePossibleTargets()
        area.clear()

        entity.getBoard().forEachStack() (BoardStack t) ->
            if t.getPlayer() != entity.getPlayer()
                area.add(t.getCell())

    private function showPreview(Cell fromCell)
        let power = hero.stats.getPower()
        let tt = createTooltip(power, level, stunLevel, purgeLevel, cost)
        if fromCell != null
            calculateDamage(power, level)
            damagePreview.addSpecificToTooltip(stack, fromCell.getStack(), tt)
        
        //TODO all actions do setKEy ?? pls do better
        tt.setKey(key)
        tt.display(entity.getPlayer(), true)
        UIActionWindow.updateActionPoints(entity, cost)
    
    private function hidePreview()
        UITooltip.hide(entity.getPlayer())
        UIActionWindow.updateActionPoints(entity)

    ondestroy
        if area != null
            destroy area

    /* ----------------------------------- KI ----------------------------------- */
    
    override function executeForKI(SequenzListenerStatus listener)
        Log.error("YOU NEED TO WRITE KI FOR LIGHTNING BOTL SPSPELL")
        listener.continue(-1)