package RallingCrySpell

import PlayerData
import BoardController


import UIMenuActionConsole
import CastAnimation
import BoardTrigger
import SpellAction
import BoardHero
import BoardEntity
import SkillTree
import StatusType
import StatusController
import Status
import WarcrySpellAction
import SkillTreeChieftain
import StatusRallingCry
import LinkedList
import BoardStack
import ActionCost
import KStringUtils
import Tooltip
import UITooltip
import ActionType
import initlater SpellType
import Spell
import HeroData
import KUtil

public class RallingCrySpell extends WarcrySpellAction
    static SpellType TYPE
    static function setup()
        STATUS_HERO = StatusRallingCry.HERO_TYPE
        STATUS = StatusRallingCry.TYPE
        TYPE = WarcrySpellAction.createType("Rallying Cry", "Icons\\BTNAbilityWarriorWarCry.blp")
        TYPE.addLevel(ActionCostPreset.create(0, false, 3), HeroDataChange.create(1, 0, 1))
        ..setIntData(ATTACK_BONUS, 3)
        TYPE.addLevel(ActionCostPreset.create(0, false, 2), HeroDataChange.create(2, 0, 1))
        ..setIntData(ATTACK_BONUS, 5)
        TYPE.addLevel(ActionCostPreset.create(0, false, 1), HeroDataChange.create(2, 0, 2))
        ..setIntData(ATTACK_BONUS, 7)
        TYPE.onActionCreate() (entity, spell) -> 
            return new RallingCrySpell(entity, spell)
        TYPE.onCreateTooltipLines() (level, spell) -> 
            return createTooltipLines(level)

    private static constant int ATTACK_BONUS = 0

    private static StatusType STATUS_HERO
    private static StatusType STATUS

    private static function createTooltipLines(SpellLevel level) returns LinkedList<string>
        return new LinkedList<string>
        ..add(KStringUtils.stat("Target", "Allies/Self"))
        ..add("")
        ..add("Gives your self and all your troops a temporary Attack Bonus")
        ..add(KStringUtils.line())
        ..addAllAndDestroy(STATUS_HERO.createTooltipLines(createStatusData(level)))
    
    private static function createStatusData(SpellLevel level) returns StatusData
        return StatusData.create(1)
        ..setIntData(ATTACK_BONUS, level.getIntData(ATTACK_BONUS))


    /* -------------------------------------------------------------------------- */

    private LinkedList<BoardStack> affectedAllies = new LinkedList<BoardStack>()

    private construct(BoardEntity entity, Spell spell)
        super(entity, spell)

    override function activate()
        CastAnimation.create(entity) -> 
            entity.getBoard().forEachStack() (BoardStack ally) ->
                if ally.getPlayer() == entity.getPlayer()
                    affectedAllies.add(ally)
                    StatusController.apply(STATUS, ally, createStatusData(level))

            StatusController.apply(STATUS_HERO, entity, createStatusData(level))
            ..addOnEndListener() (SequenzListener next) ->
                affectedAllies.forEach() (BoardStack ally) ->
                    if ally.isAlive()
                        StatusController.remove(STATUS, ally)
                next.continue()

            BoardController.finishOrder(entity, cost)

    private function showPreview()
        let tt = createBasicTooltip()
        ..addLines(createTooltipLines(level))
        UITooltip.display(entity.getPlayer(), tt)
        UIMenuActionConsole.updateActionPoints(entity, cost)

    private function hidePreview()
        UITooltip.hide(entity.getPlayer())
        UIMenuActionConsole.updateActionPoints(entity)

    override function onUIMouseEnter()
        showPreview()

    override function onUIMouseLeave()
        hidePreview()

    ondestroy