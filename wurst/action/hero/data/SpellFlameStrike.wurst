package SpellFlameStrike

import LinkedList
import Doodads

import PlayerData
import KUtil
import BoardController

import Action

import initlater Cell
import initlater BoardStack
import UIMenuActionConsole
import AnimationWait
import Damage
import AnimationCast
import SpellAction
import BoardHero
import BoardEntity
import StatusType
import StatusController
import Status
import UIController
import StatusPurged
import ActionCost
import KStringUtils
import Tooltip
import UITooltip
import DamageAndResistance
import initlater SpellType
import HeroData
import Spell
import Icons
import Abilities
import Scheduler

public class SpellFlameStrike extends SpellAction
    static SpellType TYPE
    static function setup()
        TYPE = SpellAction.createType("Flame Strike", Icons.bTNWallOfFire)
        TYPE.addLevel(ActionCostPreset.createWithMana(1, true, 6), HeroDataChange.create(1, 0, 3))
        ..setIntData(DAMAGE, 90)
        TYPE.addLevel(ActionCostPreset.createWithMana(1, true, 9), HeroDataChange.create(1, 0, 5))
        ..setIntData(DAMAGE, 150)
        TYPE.addLevel(ActionCostPreset.createWithMana(1, true, 12), HeroDataChange.create(2, 0, 8))
        ..setIntData(DAMAGE, 300)
        TYPE.onActionCreate() (entity, spell) -> 
            return new SpellFlameStrike(entity, spell)
        TYPE.onCreateTooltipLines() (level, spellStats) -> 
            return createTooltipLines(level, spellStats)

    private static constant int DAMAGE = 0

    private static constant DamagePreview damagePreview = DamagePreview.create(SourceType.SPELL, DamageType.FIRE)
    
    private static function calculateDamage(SpellLevel level, HasSpellStats spellStats) returns DamagePreview
        var multi = 1.0
        if spellStats != null
            multi = spellStats.getDamageMulti()
        let baseDamage = level.getIntData(DAMAGE)
        damagePreview.dmg = realRange(baseDamage * 0.8 * multi, baseDamage * 1.2 * multi)
        return damagePreview

    private static function createTooltipLines(SpellLevel level, HasSpellStats spellStats) returns LinkedList<string>
        return new LinkedList<string>
        ..add(KStringUtils.stat("Target", "Area"))
        ..add(KStringUtils.stat("Damage", calculateDamage(level, spellStats).toColoredText()))
        ..add("")
        ..add("Conjures a pillar of fire which damages enemys in a target area.")
    
    /* -------------------------------------------------------------------------- */

    private LinkedList<Cell> area = new LinkedList<Cell>()
    private LinkedList<BoardStack> targets = new LinkedList<BoardStack>()

    private construct(BoardEntity entity, Spell spell)
        super(entity, spell)

    override function getHighlightResultForCell(Player p, Cell cell) returns CellResult
        if area.has(cell)
            return CellResult.NEGATIVE
        return CellResult.NONE

    override function recalculatePreview()
        //

    override function recalculateHighlight(Player p)
        let highlightedCell = p.currentMousePosition.cell
        if highlightedCell == null
            hidePreview()
            return
        
        area.clear()
        targets.clear()
        highlightedCell.forEachCellsInRange(intRange(0, 1)) cell ->
            area.add(cell)
            let possibleTarget = cell.getStack()
            if possibleTarget != null
                targets.add(possibleTarget)
            
        showPreview(true)

    override function castAt(Cell cell) returns boolean
        AnimationCast.atCell(hero, cell) () ->
            let e = addEffect(Abilities.flameStrike, cell.getCoord())
            AnimationWait.time(entity.getBoard(), 0.2) ->
                e.destr()
                hitNextTarget(targets.iterator(), calculateDamage(level, this).getRandomInstance(), Scheduler.getTimeIn(0.667))
            
        return true

    private function hitNextTarget(LLIterator<BoardStack> stackItr, DamageInstance rolledDamage, real delayUntil)
        if not stackItr.hasNext()
            destroy rolledDamage
            AnimationWait.untill(entity.getBoard(), delayUntil) ->
                finishCast(true)
            return
        
        BoardController.dealDamage(hero, rolledDamage, stackItr.next()) -> 
            hitNextTarget(stackItr, rolledDamage, delayUntil)

    private function showPreview(boolean showTargets)
        let tt = createBasicTooltip()
        ..addLines(createTooltipLines(level, this))
        if showTargets
            for target in targets
                tt.addLine("")
                calculateDamage(level, this)
                .extendTooltipWithSpecific(tt, entity, target)
        
        UITooltip.display(entity.getPlayer(), tt)
        UIMenuActionConsole.updateActionPoints(entity, cost)
    
    private function hidePreview()
        UITooltip.hide(entity.getPlayer())
        UIMenuActionConsole.updateActionPoints(entity)

    override function onUIMouseEnter()
        showPreview(false)

    override function onUIMouseLeave()
        hidePreview()

    ondestroy
        if area != null
            destroy area
        if targets != null
            destroy targets