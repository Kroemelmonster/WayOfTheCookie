package SpellChainLightning

import LinkedList
import Icons
import Abilities

import PlayerData
import KUtil
import BoardController

import Action
import StackType

import initlater Cell
import initlater BoardStack
import UIMenuActionConsole
import AnimationWait
import Damage
import AnimationCast
import BoardTrigger
import SpellAction
import BoardHero
import BoardEntity
import SkillTreeTempestarii
import SkillTree
import Globals
import ActionCost
import KStringUtils
import Tooltip
import UITooltip
import DamageAndResistance
import ActionType
import initlater SpellType
import HeroData
import Spell

public class SpellChainLightning extends SpellAction
    static SpellType TYPE
    static function setup()
        TYPE = SpellAction.createType("Chain Lightning", Icons.bTNChainLightning)
        TYPE.addLevel(ActionCostPreset.createWithMana(1, true, 7), HeroDataChange.create(0, 1, 3))
        ..setIntData(DAMAGE, 65)
        ..setIntData(CHAINS, 2)
        TYPE.addLevel(ActionCostPreset.createWithMana(1, true, 12), HeroDataChange.create(0, 2, 5))
        ..setIntData(DAMAGE, 125)
        ..setIntData(CHAINS, 3)
        TYPE.addLevel(ActionCostPreset.createWithMana(1, true, 20), HeroDataChange.create(0, 3, 7))
        ..setIntData(DAMAGE, 185)
        ..setIntData(CHAINS, 4)
        TYPE.onActionCreate() (entity, spell) -> 
            return new SpellChainLightning(entity, spell)
        TYPE.onCreateTooltipLines() (level, spellStats) -> 
            return createTooltipLines(level, spellStats)

    private static constant int DAMAGE = 0
    private static constant int CHAINS = 1

    private static constant int CHAIN_RANGE = 3
    private static constant real CHAIN_REDUCTION = 0.90
    private static constant DamagePreview damagePreview = DamagePreview.create(SourceType.SPELL, DamageType.MAGIC)

    private static function calculateDamage(SpellLevel level, HasSpellStats spellStats, int amountOfChained) returns DamagePreview
        var multi = 1.0
        for i = 1 to amountOfChained
            multi *= CHAIN_REDUCTION
        if spellStats != null
            multi *= spellStats.getDamageMulti()
        let baseDamage = level.getIntData(DAMAGE)
        damagePreview.dmg = realRange(baseDamage * 0.65 * multi, baseDamage* 1.85 * multi)
        return damagePreview

    private static function createTooltipLines(SpellLevel level, HasSpellStats spellStats) returns LinkedList<string>
        return new LinkedList<string>
        ..add(KStringUtils.stat("Target", "Enemy"))
        ..add(KStringUtils.stat("Damage", calculateDamage(level, spellStats, 0).toColoredText()))
        ..add("")
        ..add("You strike a Foe with Lightning which chains up to "
         + KStringUtils.primaryString(level.getIntData(CHAINS).toString()) + " times")
        ..add("Each time the damage is descreased by "
         + KStringUtils.primaryPercent(1 - CHAIN_REDUCTION))

    /* -------------------------------------------------------------------------- */
    
    private LinkedList<Cell> area = new LinkedList<Cell>()

    construct(BoardEntity entity, Spell spell)
        super(entity, spell)

    override function getHighlightResultForCell(Player p, Cell cell) returns CellResult
        if area.has(cell)
            return CellResult.NEGATIVE
        return CellResult.NONE

    override function recalculatePreview()
        recalculatePossibleTargets()

    override function recalculateHighlight(Player p)
        if area.has(p.currentMousePosition.cell)
            showPreview(p.currentMousePosition.cell)
        else
            hidePreview()

    override function castAt(Cell cell) returns boolean
        if not area.has(cell)
            return false
        AnimationCast.atCell(hero, cell) () ->
            let rolledBaseDamage = calculateDamage(level, this, 0).getRandomInstance()
            chainToNext(new LinkedList<BoardStack>(), entity, rolledBaseDamage, cell.getStack(), 0)
        return true

    private function chainToNext(LinkedList<BoardStack> prevTargets, BoardEntity prev, DamageInstance baseDamage, BoardStack target, int chains)
        let targetPos = target.getPos3Real()
        var lightningModel = LIGHTNING_CHAIN_LIGHTNING_SEECONDARY
        if chains == 0
            lightningModel = LIGHTNING_CHAIN_LIGHTNING_PRIMARY
        let bolt = addLightning(lightningModel, true, prev.getPos3Real(), targetPos)
        let e = addEffect(Abilities.boltImpact, targetPos)
        AnimationWait.time(entity.getBoard(), 0.3) ->
            bolt.destr()
            e.setPosition(-100000, -10000, 10000)
            e.destr()
            let targetCell = target.getCell()
            BoardController.dealDamage(hero, baseDamage, target) -> 
                var continue = chains < level.getIntData(CHAINS)
                if continue
                    prevTargets.add(target)
                    baseDamage.dmg *= CHAIN_REDUCTION

                    Cell _newTargetCell = null
                    if target.isOnBoard()
                        // why not just use targetCell ?? because the unit might be moved so the chain goes on from there :O
                        _newTargetCell = target.getCell()
                    else
                        _newTargetCell = targetCell
                    let _nextTarget = getNextTarget(prevTargets, _newTargetCell)
                    if _nextTarget == null
                        continue = false
                    else
                        chainToNext(prevTargets, target, baseDamage, _nextTarget, chains + 1)
                if not continue
                    destroy prevTargets
                    destroy baseDamage
                    finishCast(true)

    private function getNextTarget(LinkedList<BoardStack> prevTargets, Cell fromCell) returns BoardStack
        BoardStack nextTarget = null
        let itr = fromCell.eachCellInRangeIterator(intRange(1, CHAIN_RANGE))
        while itr.hasNext() and nextTarget == null
            let cell = itr.next()
            let possibleTarget = cell.getStack()
            if possibleTarget != null and possibleTarget.isEnemy(entity) and not prevTargets.has(possibleTarget)
                nextTarget = possibleTarget

        destroy itr
        return nextTarget

    private function recalculatePossibleTargets()
        area.clear()

        entity.getBoard().forEachStack() (BoardStack t) ->
            if t.getPlayer() != entity.getPlayer()
                area.add(t.getCell())

    private function showPreview(Cell fromCell)
        let tt = createBasicTooltip()
        ..addLines(createTooltipLines(level, this))
        if fromCell != null
            tt.addLine("")

            let list = new LinkedList<BoardStack>()
            list.add(fromCell.getStack())
            var chains = 0
            var continue = true
            while continue
                let currentTarget = list.peek()
                calculateDamage(level, this, chains)
                .extendTooltipWithSpecific(tt, entity, currentTarget)
                let nextTarget = getNextTarget(list, currentTarget.getCell())
                continue = (nextTarget != null)
                if continue
                    list.add(nextTarget)
                    continue = chains < level.getIntData(CHAINS)
                    chains++
            destroy list
        
        UITooltip.display(entity.getPlayer(), tt)
        UIMenuActionConsole.updateActionPoints(entity, cost)
    
    private function hidePreview()
        UITooltip.hide(entity.getPlayer())
        UIMenuActionConsole.updateActionPoints(entity)

    override function onUIMouseEnter()
        showPreview(null)

    override function onUIMouseLeave()
        hidePreview()


    ondestroy
        if area != null
            destroy area