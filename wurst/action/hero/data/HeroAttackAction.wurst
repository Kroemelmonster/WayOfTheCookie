package HeroAttackAction

import LinkedList

import Action

import PathFinding

import PlayerData
import Damage
import DefaultAction
import BoardController
import KUtil

import initlater Cell
import initlater BoardStack
import initlater Board
import BoardTrigger
import KISystem
import ClosureTimers
import initlater BoardHero
import HeroAttackAnimation
import StackType
import ActionCost
import Tooltip
import UITooltip
import ActionType
import BoardEntity
import UIMenuActionConsole

public class HeroAttackAction extends DefaultAction
    static ActionType TYPE
    static function setup()
        TYPE = DefaultAction.createType("Attack")
        TYPE.onCreate() entity -> 
            return new HeroAttackAction(entity)
        TYPE.onCreateTooltipLines() amount -> 
            return new LinkedList<string>

    protected BoardHero hero

    construct(BoardEntity entity)
        super(entity, TYPE, ActionCostPreset.create(1, true))
        if entity.getType() != EntityType.HERO
            Log.error("Tried to add a HeroAttackAction to an non Hero")
        this.hero = entity.toHero()

    override function getPreviewResultForCell(Cell cell) returns CellResult
        if isCellAttackable(cell)
            return CellResult.NEGATIVE
        return CellResult.NONE

    override function getHighlightResultForCell(Player p, Cell cell) returns CellResult
        if isCellAttackable(cell)
            return CellResult.NEGATIVE
        return CellResult.NONE

    override function recalculatePreview()

    override function recalculateHighlight(Player p)
        let cell = p.currentMousePosition.cell
        if isCellAttackable(cell)
            let tt = createBasicTooltip()
            let preview = new DamagePreview(hero.stats.getDamage(), SourceType.ATTACK, hero.stats.getDamageType())
            preview.extendTooltipWithSpecific(tt, entity, cell.getStack())
            destroy preview
            UITooltip.display(entity.getPlayer(), tt)
            UIMenuActionConsole.updateActionPoints(entity, cost)
        else
            UITooltip.hide(entity.getPlayer())
            UIMenuActionConsole.updateActionPoints(entity)
        /*
        let cell = p.currentMousePosition.cell
        caclulatePath(cell, p.currentMousePosition.nearbyCell)
        if hasValidTarget == false
            UITooltip.hide(stack.getPlayer())
        else
            let tt = Tooltip.create(name)
            let preview = new DamagePreview(stack.stats.getDamage(), SourceType.ATTACK, stack.stats.getDamageType())
            preview.addSpecificToTooltip(stack, cell.getStack(), tt)
            destroy preview
            tt.display(stack.getPlayer(), true)
        
        var showCost = 0
        if cell != null
            if canAttackTargetThisTurn(cell.getStack())
                showCost = 99
            else if cell != stack.getCell()
                let remaining = getRemainingActionPointsFromCell(cell, stack.stats.getMoveSpeed())
                if remaining >= 0
                    showCost = stack.stats.getMoveSpeed().floor() - remaining
            
        UIActionWindow.updateActionPoints(stack, showCost)
        */

    override function sendTargetOrder(Cell cell) returns boolean
        if isCellAttackable(cell)
            let defender = cell.getStack()
            HeroAttackAnimation.create(entity, defender) () ->
                let preview = new DamagePreview(hero.stats.getDamage(), SourceType.ATTACK, hero.stats.getDamageType())
                let instance = preview.getRandomInstance()
                destroy preview
                BoardController.dealDamage(hero, instance, defender) ->
                    BoardController.finishOrder(entity, cost)
            return true
        return false

    private function isCellAttackable(Cell cell) returns boolean
        if cell == null
            return false
        let target = cell.getStack()
        return target != null and entity.getPlayer().isEnemyTo(target.getPlayer())


    override function getTargets(boolean shouldBeAbleToAttackThisTurn) returns LinkedList<BoardStack>
        return entity.getBoard().getAllStacks()

    override function caclulatePath(Cell targetCell, Cell preferedCell) returns Cell
        return targetCell

    override function getPathing() returns StackPathFinding
        return null // TODO...

    override function executeForKI(SequenzListenerStatus listener)
        BoardStack enemy = KISystem.getBestTarget(getTargets(true))
        if enemy == null
            enemy = KISystem.getBestTarget(getTargets(false))
        
        nullTimer() ->
            if enemy == null
                listener.continue(1)
            else
                let order = caclulatePath(enemy.getCell(), null)
                sendTargetOrder(order)
                listener.continue(0)
    
                
    ondestroy
  
        