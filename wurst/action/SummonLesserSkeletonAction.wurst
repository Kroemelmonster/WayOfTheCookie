package SummonLesserSkeletonAction

import LinkedList
import Icons
import Abilities

import PlayerData
import KUtil
import UITooltip
import BoardController
import OrderSystem

import Action
import StackType

import initlater Cell
import initlater BoardStack
import initlater StackTypesDefinition
import UIActionWindow
import Scheduler
import DelayAnimation
import CastAnimation
import BoardTrigger
import ClosureTimers

public class SummonLesserSkeletonAction extends Action
    static constant string NAME = "Summon Skeleton"
    static constant string ICON = Icons.bTNRaiseDead

    private static constant int COST = 2
    private static constant int COOLDOWN = 3
    private static constant int MAXRANGE = 1
    private static constant string EFFECT = Abilities.raiseSkeleton
    private static constant string KEY = "S"
    private static StackType SUMMONED_TYPE
    private static Tooltip BASE_TOOLTIP

    static function setup()
        SUMMONED_TYPE = StackTypes.LESSER_SKELETON
        BASE_TOOLTIP = Tooltip.create(NAME)
        ..setCooldown(COOLDOWN)
        ..setCost(COST)
        
        ..addLine(Tooltip.stat("Target", "Empty Cell"))
        ..addLine(Tooltip.stat("Range", MAXRANGE))
        ..addLine("")
        ..addLine("")

    private static function getSummonLeadershipAmount(StackType sType) returns intRange
        return intRange((sType.leadership * 0.3).ceil(), (sType.leadership * 0.6).ceil())

    static function createTooltip(StackType sType) returns Tooltip
        let leadership = getSummonLeadershipAmount(sType)
        let str = "Summons a Stack of "+ Tooltip.coloredString(Tooltip.COLOR_SECONDARY, SUMMONED_TYPE.name) +" with a Leaderhip of "+Tooltip.coloredRange(Tooltip.COLOR_PRIMARY, leadership)
        let tt = Tooltip.copy(BASE_TOOLTIP)
        ..setLine(3, str)

        return tt

    private LinkedList<Cell> area = new LinkedList<Cell>()
    private Tooltip tooltip
    private intRange summonAmount  

    construct(BoardStack stack)
        super(stack, ICON, NAME)
        tooltip = Tooltip.copy(BASE_TOOLTIP)
        ..addKey(KEY)

    override function getHighlightResultForCell(Player p, Cell cell) returns CellResult
        if area.has(cell)
            return CellResult.NEUTRAL
        return CellResult.NONE

    override function recalculatePreview()
        recalculate()

    override function recalculateHighlight(Player p)
        if area.has(p.currentMousePosition.cell)
            showPreview()
        else
            hidePreview()

    override function sendTargetOrder(Cell cell) returns boolean
        if area.has(cell)
            recalcSummonAmount()
            let summon = cell.getBoard().createSummon(stack.getPlayer(), SUMMONED_TYPE, summonAmount.random())

            CastAnimation.create(stack, cell) () ->
                flashEffect(EFFECT, cell.getCoord())
                BoardController.placeStackOnBoard(summon, cell, true) ->
                    let delayTime = Scheduler.getTimeIn(0.5) // this is the backswing for casting
                    DelayAnimation.create(cell.getBoard(), delayTime) ->
                        cooldown = COOLDOWN + 1
                        BoardController.finishOrder(entity, false)
            
            return true
        
        return false

    private function recalcSummonAmount()
        let amount = stack.stats.getAmount()
        let leadershipAmount = getSummonLeadershipAmount(stack.getStackType())
        summonAmount = intRange((leadershipAmount.min * amount / SUMMONED_TYPE.leadership).ceil(), (leadershipAmount.max * amount / SUMMONED_TYPE.leadership).ceil())
        
        var str = "Summons a Stack of "+ Tooltip.coloredRange(Tooltip.COLOR_PRIMARY, summonAmount)
        str += " " + Tooltip.coloredString(Tooltip.COLOR_SECONDARY, SUMMONED_TYPE.name)
        tooltip.setLine(3, str)

    private function recalculate()
        area.clear()
        recalcSummonAmount()

        stack.getCell().forEachCellsInRange(intRange(1, MAXRANGE)) (Cell cell) ->
            if cell.getStack() == null
                area.add(cell)

    override function canActivate() returns boolean
        return stack.stats.getRemainingActionPoints() >= COST and cooldown <= 0

    @inline
    private function showPreview()
        tooltip.display(stack.getPlayer(), false)
        UIActionWindow.updateActionPoints(entity, 99)
                
    @inline
    private function hidePreview()
        UITooltip.hide(stack.getPlayer())
        UIActionWindow.updateActionPoints(entity, 0)

    override function onUIMouseEnter()
        recalcSummonAmount()
        showPreview()

    override function onUIMouseLeave()
        hidePreview()

    override function canBeActivatedByKey(string key) returns boolean
        return key == KEY

    override function executeForKI(SequenzListenerStatus listener)
        // just someone it when there is a place
        recalculate()
        if area.isEmpty()
            listener.continue(1)
        else
            activate()
            nullTimer() ->
                let random = area.get(GetRandomInt(0, area.size() - 1))
                sendTargetOrder(random)


    ondestroy
        if area != null
            destroy area
        if tooltip != null
            destroy tooltip
        